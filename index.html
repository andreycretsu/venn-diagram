<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Card Canvas</title>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎯</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-border: #e2e8f0;
            --color-text-primary: #1e293b;
            --color-primary: #3b82f6;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --radius-lg: 12px;
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--color-background);
            color: var(--color-text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--color-background);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--color-background);
            /* Stylish grid background with dots and lines */
            background-image: 
                /* Large dots every 100px */
                radial-gradient(circle at 2px 2px, rgba(59, 130, 246, 0.15) 1px, transparent 1px),
                /* Small dots every 20px */
                radial-gradient(circle at 1px 1px, rgba(148, 163, 184, 0.1) 0.5px, transparent 0.5px),
                /* Vertical lines every 200px */
                linear-gradient(90deg, rgba(148, 163, 184, 0.1) 1px, transparent 1px),
                /* Horizontal lines every 200px */
                linear-gradient(0deg, rgba(148, 163, 184, 0.1) 1px, transparent 1px);
            background-size: 
                100px 100px,  /* Large dots spacing */
                20px 20px,    /* Small dots spacing */
                200px 100%,   /* Vertical lines spacing */
                100% 200px;   /* Horizontal lines spacing */
            background-position:
                0 0,          /* Large dots offset */
                0 0,          /* Small dots offset */
                0 0,          /* Vertical lines offset */
                0 0;          /* Horizontal lines offset */
            animation: gridMove 60s linear infinite;
        }

        @keyframes gridMove {
            0% { 
                background-position: 0 0, 0 0, 0 0, 0 0; 
            }
            100% { 
                background-position: 100px 100px, 20px 20px, 200px 0, 0 200px; 
            }
        }

        /* Responsive grid patterns */
        @media (max-width: 768px) {
            .canvas-container {
                background-size: 
                    50px 50px,    /* Smaller large dots on mobile */
                    15px 15px,    /* Smaller small dots */
                    100px 100%,   /* Closer vertical lines */
                    100% 100px;   /* Closer horizontal lines */
            }
            
            @keyframes gridMove {
                0% { 
                    background-position: 0 0, 0 0, 0 0, 0 0; 
                }
                100% { 
                    background-position: 50px 50px, 15px 15px, 100px 0, 0 100px; 
                }
            }
        }

        @media (min-width: 1920px) {
            .canvas-container {
                background-size: 
                    150px 150px,  /* Larger spacing on big screens */
                    30px 30px,    /* Larger small dots */
                    300px 100%,   /* Wider vertical spacing */
                    100% 300px;   /* Wider horizontal spacing */
            }
        }

        .canvas-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(
                ellipse at center,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(59, 130, 246, 0.02) 50%,
                rgba(148, 163, 184, 0.05) 100%
            );
            pointer-events: none;
            z-index: 1;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: transparent;
            cursor: default;
            position: relative;
            z-index: 2;
        }

        .floating-controls {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            z-index: 1000;
        }

        .floating-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: var(--color-primary);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }

        .floating-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.2);
        }

        .floating-button.success { background: #10b981; }
        .floating-button.active { background: #8b5cf6; }
        .floating-button.inactive { background: #64748b; }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-md);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--color-text-primary);
        }

        .form-group {
            margin-bottom: var(--space-md);
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text-primary);
            border: 1px solid var(--color-border);
        }

        .modal-footer {
            display: flex;
            gap: var(--space-md);
            justify-content: flex-end;
            margin-top: var(--space-lg);
        }

        .notification {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            z-index: 3000;
            max-width: 300px;
        }

        .notification.success { border-left: 4px solid #10b981; }
        .notification.error { border-left: 4px solid #ef4444; }
        .notification.info { border-left: 4px solid var(--color-primary); }

        .floating-button.controls { background: #8b5cf6; }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            left: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            font-size: 14px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulseSave {
            0% { 
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            }
        }

        .floating-button.pulse {
            animation: pulseSave 1.5s ease-in-out infinite;
        }

        .file-upload-area {
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--color-surface);
        }

        .file-upload-area:hover {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .file-upload-area.drag-over {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .upload-content i {
            font-size: 24px;
            color: var(--color-primary);
            margin-bottom: 8px;
        }

        .upload-content p {
            margin: 4px 0;
            font-size: 14px;
        }

        .upload-hint {
            color: #64748b;
            font-size: 12px !important;
        }

        .logo-preview {
            position: relative;
            max-width: 120px;
            margin: 0 auto;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 8px;
            background: white;
        }

        .logo-preview img {
            width: 100%;
            height: auto;
            max-height: 60px;
            object-fit: contain;
        }

        .remove-logo {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 1000;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
        }

        .control-group {
            margin-bottom: var(--space-md);
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--color-text-primary);
        }

        .control-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .control-slider {
            width: 100%;
            height: 4px;
            background: var(--color-border);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .control-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <!-- Circle Controls Modal -->
        <div class="modal" id="controlsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Circle Controls</h2>
                    <button class="modal-close" onclick="closeModal('controlsModal')">×</button>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Radius: <span id="radiusValue">300</span>px</label>
                    <input type="range" id="radiusSlider" min="50" max="500" value="300" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Distance: <span id="distanceValue">200</span>px</label>
                    <input type="range" id="distanceSlider" min="50" max="300" value="200" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Card Size: <span id="cardSizeValue">64</span>px</label>
                    <input type="range" id="cardSizeSlider" min="40" max="120" value="64" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showCirclesCheckbox" checked> Show Circles
                    </label>
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showPointACheckbox"> Show Point A (Global)
                    </label>
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="closeModal('controlsModal')">Done</button>
                </div>
            </div>
        </div>

        <!-- Auto-save Status -->
        <div class="autosave-status" id="autosaveStatus">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Checking connection...</span>
        </div>

        <div class="floating-controls">
            <button class="floating-button" onclick="openAddCardModal()" title="Add Card">
                <i class="fas fa-plus"></i>
            </button>
            <button class="floating-button" onclick="addPointBToSelected()" title="Add Point B" id="addPointBFab" style="display: none;">
                <i class="fas fa-code-branch"></i>
            </button>
            <button class="floating-button" onclick="toggleControlsModal()" title="Circle Controls" id="controlsFab">
                <i class="fas fa-sliders-h"></i>
            </button>
            <button class="floating-button" onclick="testConnection()" title="Test Sync" id="syncTestFab" style="background: #f59e0b;">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button class="floating-button success" onclick="exportCanvas()" title="Export">
                <i class="fas fa-download"></i>
            </button>
        </div>
    </div>

    <!-- Add Card Modal -->
    <div class="modal" id="addCardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Business Card</h2>
                <button class="modal-close" onclick="closeModal('addCardModal')">×</button>
            </div>
            
            <div class="form-group">
                <label class="form-label">Company Name</label>
                <input type="text" id="companyName" class="form-input" placeholder="Enter company name">
            </div>
            
            <div class="form-group">
                <label class="form-label">Logo Selection</label>
                <select id="logoSelect" class="form-select" onchange="handleLogoSelect()">
                    <option value="">-- Select from available logos --</option>
                    <option value="adp.svg">ADP</option>
                    <option value="amp.svg">AMP</option>
                    <option value="bamboohr.svg">BambooHR</option>
                    <option value="brex.svg">Brex</option>
                    <option value="deel.svg">Deel</option>
                    <option value="factorial.svg">Factorial</option>
                    <option value="hibob.svg">HiBob</option>
                    <option value="justworks.svg">JustWorks</option>
                    <option value="lattice.svg">Lattice</option>
                    <option value="paychex.svg">Paychex</option>
                    <option value="paycom.svg">Paycom</option>
                    <option value="paylocity.svg">Paylocity</option>
                    <option value="personio.svg">Personio</option>
                    <option value="pleo.svg">Pleo</option>
                    <option value="ramp.svg">Ramp</option>
                    <option value="remote.svg">Remote</option>
                    <option value="revolut.svg">Revolut</option>
                    <option value="rippling.svg">Rippling</option>
                    <option value="spendesk.svg">Spendesk</option>
                    <option value="swile.svg">Swile</option>
                    <option value="teamtailor.svg">Teamtailor</option>
                    <option value="workable.svg">Workable</option>
                    <option value="workday.svg">Workday</option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label">Or Upload Custom Logo</label>
                <div class="file-upload-area" id="logoUploadArea">
                    <div class="upload-content">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Drag & drop SVG/PNG files or SVG code here</p>
                        <p class="upload-hint">or click to browse</p>
                    </div>
                    <input type="file" id="logoFileInput" accept=".svg,.png,image/svg+xml,image/png" style="display: none;">
                    <div class="logo-preview" id="logoPreview" style="display: none;">
                        <img id="logoPreviewImg" alt="Logo preview">
                        <button type="button" class="remove-logo" onclick="removeLogo()">&times;</button>
                    </div>
                </div>
            </div>
            

            
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addCardModal')">Cancel</button>
                <button class="btn btn-primary" onclick="addBusinessCard()">Add Card</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        // REAL Supabase setup - configured with your project
        const supabaseConfig = {
            url: 'https://djoboiwyethvkswrhlsp.supabase.co',
            key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRqb2JvaXd5ZXRodmtzd3JobHNwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk0NjYzMDYsImV4cCI6MjA2NTA0MjMwNn0.69O6lLpFYkh7Y9fIMCeAq81b-TVC_uN_XRn34SVWCYI'
        };

        // Skip bucket creation if we can't create it due to RLS
        const SKIP_BUCKET_CREATION = true;

        // Global Supabase client
        let supabaseClient = null;

        // Business Card Canvas with REAL Supabase
        class BusinessCardCanvas {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cards = [];
                this.selectedCards = [];
                this.clickPosition = { x: 0, y: 0 };
                this.showCircles = true;
                this.showPointA = false; // Global toggle for Point A visibility
                this.isDragging = false;
                this.dragStartPos = null;
                this.dragOffset = null;
                this.hoveredCard = null;
                this.loadedLogos = new Map();
                this.animationFrameId = null;
                this.connections = [];
                this.lastMousePos = { x: 0, y: 0 };
                this.hasChanges = false;
                this.autosaveInterval = null;
                
                this.circleRadius = 300;
                this.centerDistance = 200;
                this.cardSize = 64;
                
                // Real collaboration setup
                this.supabase = null;
                this.subscription = null;
                this.isConnected = false;
                this.isUpdating = false;
                this.dragSaveTimeout = null;
                
                this.init();
            }

            init() {
                // Clear any old localStorage data to start fresh
                localStorage.removeItem('venn-canvas-local');
                console.log('🧹 Cleared localStorage - starting with clean canvas');
                
                this.initSupabase();
                this.resizeCanvas();
                this.setupEventListeners();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.render();
            }

            async initSupabase() {
                try {
                    console.log('🔄 Initializing Supabase for cloud autosave...');
                    
                    // Try to connect to Supabase
                    const connected = await this.connectToSupabase();
                    
                    if (connected) {
                        console.log('✅ Supabase connected - autosave enabled');
                        this.updateStatus('connected', 'Cloud autosave active');
                        
                        // Load data from Supabase
                        await this.loadFromSupabase();
                        
                        // Set up real-time sync
                        this.setupRealTimeSubscription();
                        
                        // Set up autosave interval
                        this.setupAutosave();
                    } else {
                        // Fallback to localStorage
                        console.log('⚠️ Using local storage only');
                        this.updateStatus('disconnected', 'Local storage only');
                        this.loadFromStorage();
                        if (this.cards.length === 0) {
                            this.initializeCleanCanvas();
                        }
                    }
                    
                } catch (error) {
                    console.error('❌ Error in initSupabase:', error);
                    this.updateStatus('disconnected', 'Sync Failed - ' + error.message.substring(0, 30));
                    this.loadFromStorage();
                    if (this.cards.length === 0) {
                        this.initializeCleanCanvas();
                    }
                }
            }

            async connectToSupabase() {
                try {
                    console.log('🔗 Testing Supabase connection...', {
                        url: supabaseConfig.url,
                        keyLength: supabaseConfig.key.length
                    });
                    
                    supabaseClient = supabase.createClient(supabaseConfig.url, supabaseConfig.key);
                    
                    // Test connection with more detailed error info
                    const { data: testData, error: testError } = await supabaseClient
                        .from('canvas_data')
                        .select('id, cards, connections, settings')
                        .limit(1);
                    
                    if (testError) {
                        console.log('🔍 Supabase test error:', testError);
                        
                        if (testError.code === 'PGRST116') {
                            // Table doesn't exist
                            console.log('📋 Table canvas_data does not exist');
                            await this.createSupabaseTable();
                            return false; // Let user create table manually
                        } else if (testError.code === '42P01') {
                            // Relation does not exist
                            console.log('📋 Database relation does not exist');
                            await this.createSupabaseTable();
                            return false;
                        } else {
                            // Other error
                            console.error('❌ Supabase error:', testError.message);
                            throw new Error(`Database error: ${testError.message}`);
                        }
                    }
                    
                    console.log('✅ Supabase connection successful!', { 
                        dataFound: testData?.length || 0 
                    });
                    
                    this.supabase = supabaseClient;
                    this.isConnected = true;
                    return true;
                    
                } catch (error) {
                    console.error('❌ Supabase connection failed:', {
                        error: error.message,
                        code: error.code,
                        details: error.details
                    });
                    return false;
                }
            }

            async createSupabaseTable() {
                console.log('');
                console.log('🚀 SUPABASE SETUP REQUIRED!');
                console.log('');
                console.log('📋 Please run this SQL in your Supabase SQL Editor:');
                console.log('');
                console.log(`-- Create the main table
CREATE TABLE IF NOT EXISTS canvas_data (
    id text PRIMARY KEY DEFAULT 'shared-canvas',
    cards jsonb DEFAULT '[]'::jsonb,
    connections jsonb DEFAULT '[]'::jsonb,
    settings jsonb DEFAULT '{}'::jsonb,
    updated_at timestamp with time zone DEFAULT now()
);

-- Enable real-time updates
ALTER PUBLICATION supabase_realtime ADD TABLE canvas_data;

-- Insert initial row
INSERT INTO canvas_data (id) VALUES ('shared-canvas')
ON CONFLICT (id) DO NOTHING;

-- Optional: Enable Row Level Security
ALTER TABLE canvas_data ENABLE ROW LEVEL SECURITY;

-- Optional: Allow anonymous access (for demo purposes)
CREATE POLICY "Allow anonymous access" ON canvas_data
    FOR ALL
    TO anon
    USING (true)
    WITH CHECK (true);`);
                console.log('');
                console.log('⚡ After running the SQL, refresh this page to enable sync!');
                console.log('');
            }

            setupAutosave() {
                // Clear any existing interval
                if (this.autosaveInterval) {
                    clearInterval(this.autosaveInterval);
                }
                
                // Autosave every 3 seconds if there are changes
                this.autosaveInterval = setInterval(() => {
                    if (this.hasChanges && !this.isDragging) {
                        this.saveToSupabase();
                        this.hasChanges = false;
                    }
                }, 3000);
                
                // Also save on window blur/unload
                window.addEventListener('blur', () => {
                    if (this.hasChanges) {
                        this.saveToSupabase();
                        this.hasChanges = false;
                    }
                });
                
                window.addEventListener('beforeunload', () => {
                    if (this.hasChanges) {
                        this.saveToSupabase();
                    }
                });
            }

            updateStatus(status, text) {
                const statusText = document.getElementById('statusText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                statusText.textContent = text;
                this.isConnected = status === 'connected';
                
                if (status === 'connected') {
                    statusText.style.color = '#10b981';
                    statusIndicator.className = 'status-indicator';
                    statusIndicator.style.background = '#10b981';
                } else {
                    statusText.style.color = '#ef4444';
                    statusIndicator.className = 'status-indicator disconnected';
                    statusIndicator.style.background = '#ef4444';
                }
            }

            async loadFromSupabase() {
                if (!this.supabase) return;

                try {
                    console.log('📥 Loading data from Supabase...');
                    
                    const { data, error } = await this.supabase
                        .from('canvas_data')
                        .select('*')
                        .eq('id', 'shared-canvas')
                        .single();

                    if (error) {
                        if (error.code === 'PGRST116') {
                            // No data found, create initial record
                            console.log('📝 No data found, creating initial record...');
                            await this.createInitialRecord();
                            return;
                        }
                        throw error;
                    }

                    if (data && data.cards) {
                        console.log('📥 Loading saved canvas from cloud...');
                        this.cards = data.cards || [];
                        this.connections = data.connections || [];
                        
                        if (data.settings) {
                            this.circleRadius = data.settings.circleRadius || 300;
                            this.centerDistance = data.settings.centerDistance || 200;
                            this.cardSize = data.settings.cardSize || 64;
                            this.showCircles = data.settings.showCircles !== false;
                            this.showPointA = data.settings.showPointA || false;
                            this.updateControlsUI();
                        }
                        
                        // Pre-load all logos
                        this.cards.forEach(card => {
                            if (card.logo) {
                                this.loadLogo(card.logo);
                            }
                        });
                        
                        this.render();
                    } else {
                        // No saved data, start with clean canvas
                        this.initializeCleanCanvas();
                    }
                } catch (error) {
                    console.error('❌ Error loading from Supabase:', error.message);
                    this.initializeCleanCanvas();
                }
            }



            async createInitialRecord() {
                try {
                    const initialData = {
                        id: 'shared-canvas',
                        cards: [],
                        connections: [],
                        settings: {
                            circleRadius: 300,
                            centerDistance: 200,
                            cardSize: 64,
                            showCircles: true,
                            showPointA: false
                        },
                        updated_at: new Date().toISOString()
                    };

                    // Insert only if doesn't exist
                    const { error } = await this.supabase
                        .from('canvas_data')
                        .insert(initialData);

                    if (error && error.code !== '23505') { // 23505 = duplicate key
                        throw error;
                    }
                    
                    console.log('✅ Created initial Supabase record');
                    this.initializeCleanCanvas();
                } catch (error) {
                    console.error('❌ Failed to create initial record:', error.message);
                    this.initializeCleanCanvas();
                }
            }

            setupRealTimeSubscription() {
                if (!this.supabase) return;

                console.log('🔔 Setting up real-time subscription...');
                
                // Subscribe to real-time changes
                this.subscription = this.supabase
                    .channel('canvas-realtime')
                    .on('postgres_changes', 
                        { 
                            event: 'UPDATE', 
                            schema: 'public', 
                            table: 'canvas_data',
                            filter: 'id=eq.shared-canvas'
                        },
                        (payload) => {
                            if (!this.isUpdating) {
                                console.log('📡 Received real-time update from another device!');
                                this.handleRealtimeUpdate(payload.new);
                            }
                        }
                    )
                    .subscribe((status) => {
                        console.log('📡 Real-time subscription status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('✅ Real-time collaboration is ACTIVE!');
                        }
                    });
            }

            handleRealtimeUpdate(data) {
                console.log('📡 INSTANT UPDATE received from another device!', {
                    cards: data.cards?.length || 0,
                    connections: data.connections?.length || 0,
                    isDragging: this.isDragging
                });
                
                // Don't update if we're currently dragging
                if (this.isDragging) {
                    return;
                }
                
                // Update immediately for instant sync
                this.cards = data.cards || [];
                this.connections = data.connections || [];
                if (data.settings) {
                    this.circleRadius = data.settings.circleRadius || 300;
                    this.centerDistance = data.settings.centerDistance || 200;
                    this.cardSize = data.settings.cardSize || 64;
                    this.showCircles = data.settings.showCircles !== false;
                    this.showPointA = data.settings.showPointA || false;
                    this.updateControlsUI();
                }
                
                // Pre-load any new logos
                this.cards.forEach(card => {
                    if (card.logo && !this.loadedLogos.has(card.logo)) {
                        this.loadLogo(card.logo);
                    }
                });
                
                this.render();
            }

            async saveToSupabase() {
                if (!this.supabase || !this.isConnected) {
                    console.log('💾 No Supabase connection - saving locally only');
                    this.updateStatus('disconnected', 'Local storage only');
                    this.saveToStorage();
                    return;
                }

                this.isUpdating = true; // Prevent infinite loops
                
                try {
                    const saveData = {
                        id: 'shared-canvas',
                        cards: this.cards,
                        connections: this.connections,
                        settings: {
                            circleRadius: this.circleRadius,
                            centerDistance: this.centerDistance,
                            cardSize: this.cardSize,
                            showCircles: this.showCircles,
                            showPointA: this.showPointA
                        },
                        updated_at: new Date().toISOString()
                    };

                    console.log('💾 Autosaving to cloud...', { 
                        cards: this.cards.length,
                        connections: this.connections.length 
                    });

                    const { error } = await this.supabase
                        .from('canvas_data')
                        .upsert(saveData, { onConflict: 'id' });

                    if (error) {
                        console.error('❌ Supabase save error:', {
                            message: error.message,
                            code: error.code,
                            details: error.details,
                            hint: error.hint
                        });
                        throw error;
                    }

                    // Update status briefly to show save
                    this.updateStatus('connected', 'Saved to cloud ✓');
                    setTimeout(() => {
                        this.updateStatus('connected', 'Cloud autosave active');
                    }, 2000);

                } catch (error) {
                    console.error('❌ Save to Supabase failed:', {
                        message: error.message,
                        code: error.code
                    });
                    
                    // Specific error handling
                    if (error.code === '42P01') {
                        this.updateStatus('disconnected', 'Table missing - Check setup');
                    } else if (error.code === 'PGRST116') {
                        this.updateStatus('disconnected', 'No data found - Check setup');
                    } else {
                        this.updateStatus('disconnected', 'Sync Failed - ' + error.message.substring(0, 20));
                    }
                    
                    // Always save locally as backup
                    this.saveToStorage();
                    
                    // Try to reconnect after a delay
                    setTimeout(() => {
                        console.log('🔄 Attempting to reconnect...');
                        this.connectToSupabase().then(connected => {
                            if (connected) {
                                this.updateStatus('connected', 'Reconnected! ✓');
                                this.isConnected = true;
                            }
                        });
                    }, 5000);
                    
                } finally {
                    this.isUpdating = false;
                }
            }

            // Fallback localStorage methods
            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('venn-canvas-local');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.cards = data.cards || [];
                        this.connections = data.connections || [];
                        if (data.settings) {
                            this.circleRadius = data.settings.circleRadius || 300;
                            this.centerDistance = data.settings.centerDistance || 200;
                            this.cardSize = data.settings.cardSize || 64;
                            this.showCircles = data.settings.showCircles !== false;
                            this.showPointA = data.settings.showPointA || false;
                            this.updateControlsUI();
                        }
                    }
                } catch (error) {
                    console.log('Error loading local data:', error);
                }
            }

            saveToStorage() {
                const data = {
                    cards: this.cards,
                    connections: this.connections,
                    settings: {
                        circleRadius: this.circleRadius,
                        centerDistance: this.centerDistance,
                        cardSize: this.cardSize,
                        showCircles: this.showCircles,
                        showPointA: this.showPointA
                    }
                };
                localStorage.setItem('venn-canvas-local', JSON.stringify(data));
            }

            updateControlsUI() {
                document.getElementById('radiusSlider').value = this.circleRadius;
                document.getElementById('radiusValue').textContent = this.circleRadius;
                document.getElementById('distanceSlider').value = this.centerDistance;
                document.getElementById('distanceValue').textContent = this.centerDistance;
                document.getElementById('cardSizeSlider').value = this.cardSize;
                document.getElementById('cardSizeValue').textContent = this.cardSize;
                document.getElementById('showCirclesCheckbox').checked = this.showCircles;
                document.getElementById('showPointACheckbox').checked = this.showPointA;
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Store current transform
                const currentTransform = this.ctx.getTransform();
                
                // Set actual canvas size for crisp vector rendering
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale canvas back down using CSS
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context so everything draws at correct size
                this.ctx.scale(dpr, dpr);
                
                // Enable crisp text and shape rendering
                this.ctx.textRenderingOptimization = 'optimizeQuality';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Only render if not dragging
                if (!this.isDragging) {
                    this.render();
                }
            }

            setupEventListeners() {
                // Mouse move for hover effects and dragging
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    this.lastMousePos = mousePos;
                    
                    if (this.isDragging && this.selectedCards.length > 0) {
                        // Regular card dragging
                        this.canvas.style.cursor = 'grabbing';
                        
                        if (this.dragOffset) {
                            // Update card positions based on mouse position and offset
                            this.selectedCards.forEach((card, index) => {
                                card.x = mousePos.x - this.dragOffset[index].x;
                                card.y = mousePos.y - this.dragOffset[index].y;
                            });
                            
                            // Use requestAnimationFrame for smooth rendering
                            if (!this.animationFrameId) {
                                this.animationFrameId = requestAnimationFrame(() => {
                                    this.render();
                                    this.animationFrameId = null;
                                });
                            }
                        }
                    } else {
                        // Check hover state only when not dragging
                        const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                        if (hoveredCard !== this.hoveredCard) {
                            this.hoveredCard = hoveredCard;
                            
                            if (hoveredCard) {
                                // Show open hand cursor when hovering over card
                                this.canvas.style.cursor = 'grab';
                            } else {
                                // Default cursor when not over card
                                this.canvas.style.cursor = 'default';
                            }
                            
                            // Render only if hover state changed
                            this.render();
                        }
                    }
                });

                // Mouse down to start selection/dragging
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.clickPosition = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const clickedCard = this.getCardAt(this.clickPosition.x, this.clickPosition.y);
                    if (clickedCard) {
                        // Start dragging
                        this.isDragging = true;
                        this.canvas.style.cursor = 'grabbing';
                        
                        // Select card if not already selected
                        if (!this.selectedCards.includes(clickedCard)) {
                            if (!e.shiftKey) {
                                this.selectedCards = [clickedCard];
                            } else {
                                this.selectedCards.push(clickedCard);
                            }
                        }
                        
                        // Calculate offset for each selected card
                        this.dragOffset = this.selectedCards.map(card => ({
                            x: this.clickPosition.x - card.x,
                            y: this.clickPosition.y - card.y
                        }));
                        
                        // Update UI to show/hide Add Point B button
                        this.updatePointBButton();
                        
                        this.render();
                    } else {
                        // Clear selection if clicking empty space
                        this.selectedCards = [];
                        this.isDragging = false;
                        this.dragOffset = null;
                        this.updatePointBButton();
                        this.render();
                    }
                });

                // Mouse up to end dragging
                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isDragging) {
                        // Mark for autosave and log coordinate changes
                        this.hasChanges = true;
                        console.log('📍 Card positions updated:', this.cards.map(c => ({ 
                            company: c.company, 
                            x: Math.round(c.x), 
                            y: Math.round(c.y),
                            version: c.isVersion || 'normal'
                        })));
                    }
                    
                    this.isDragging = false;
                    this.dragOffset = null;
                    
                    // Reset cursor based on hover state
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                    this.canvas.style.cursor = hoveredCard ? 'grab' : 'default';
                });

                // Mouse leave to reset cursor
                this.canvas.addEventListener('mouseleave', () => {
                    if (this.isDragging) {
                        this.hasChanges = true;
                    }
                    this.isDragging = false;
                    this.dragOffset = null;
                    this.hoveredCard = null;
                    this.canvas.style.cursor = 'default';
                });
            }

            getCardAt(x, y) {
                return this.cards.find(card => {
                    const dist = Math.sqrt(
                        Math.pow(x - card.x, 2) + Math.pow(y - card.y, 2)
                    );
                    return dist <= this.cardSize / 2;
                });
            }

            updatePointBButton() {
                const btn = document.getElementById('addPointBFab');
                if (this.selectedCards.length === 1) {
                    const selectedCard = this.selectedCards[0];
                    // Check if this card already has A/B versions
                    const hasAB = this.cards.some(c => c.pairedCardId === selectedCard.id || selectedCard.isVersion);
                    if (!hasAB) {
                        btn.style.display = 'block';
                    } else {
                        btn.style.display = 'none';
                    }
                } else {
                    btn.style.display = 'none';
                }
            }

            addPointB() {
                if (this.selectedCards.length !== 1) return;
                
                const originalCard = this.selectedCards[0];
                if (originalCard.isVersion) return;
                
                // Create point A (50% transparent)
                const pointA = {
                    id: Date.now() + Math.random(),
                    company: originalCard.company,
                    logo: originalCard.logo,
                    x: originalCard.x - 100,
                    y: originalCard.y - 50,
                    isVersion: 'A',
                    opacity: 0.5,
                    pairedCardId: originalCard.id
                };
                
                // Create point B
                const pointB = {
                    id: Date.now() + Math.random() + 1,
                    company: originalCard.company,
                    logo: originalCard.logo,
                    x: originalCard.x + 100,
                    y: originalCard.y + 50,
                    isVersion: 'B',
                    pairedCardId: pointA.id
                };
                
                // Add cards
                this.cards.push(pointA);
                this.cards.push(pointB);
                
                // Create connection from A to B (center to center)
                this.connections.push({
                    id: Date.now() + Math.random(),
                    fromId: pointA.id,
                    toId: pointB.id
                });
                
                // Remove original card
                const originalIndex = this.cards.findIndex(c => c.id === originalCard.id);
                if (originalIndex > -1) {
                    this.cards.splice(originalIndex, 1);
                }
                
                // Clear selection
                this.selectedCards = [];
                this.updatePointBButton();
                this.hasChanges = true;
                this.render();
                
                app.showNotification('A/B points created! Drag to reposition them.', 'success');
            }

            getConnectionPointAt(x, y) {
                for (const card of this.cards) {
                    // Check point A (start) - only if card is hovered
                    if (this.hoveredCard === card) {
                        const startPoint = this.getConnectionPoint(card, 'start');
                        const distToStart = Math.sqrt(
                            Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
                        );
                        if (distToStart <= 8) {
                            return { card, type: 'start' };
                        }
                    }
                    
                    // Check point B (end) - always
                    const endPoint = this.getConnectionPoint(card, 'end');
                    const distToEnd = Math.sqrt(
                        Math.pow(x - endPoint.x, 2) + Math.pow(y - endPoint.y, 2)
                    );
                    if (distToEnd <= 8) {
                        return { card, type: 'end' };
                    }
                }
                return null;
            }

            toggleCardSelection(card) {
                const index = this.selectedCards.indexOf(card);
                if (index > -1) {
                    this.selectedCards.splice(index, 1);
                } else {
                    this.selectedCards.push(card);
                }
            }

            createCard(data) {
                const card = {
                    id: Date.now() + Math.random(),
                    company: data.company,
                    logo: data.logo || '',
                    x: data.x,
                    y: data.y
                };
                this.cards.push(card);
                
                // Pre-load logo if provided
                if (card.logo) {
                    this.loadLogo(card.logo);
                }
                
                // Mark for autosave
                this.hasChanges = true;
                
                return card;
            }

            async loadLogo(logoUrl) {
                if (this.loadedLogos.has(logoUrl)) return this.loadedLogos.get(logoUrl);

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        this.loadedLogos.set(logoUrl, img);
                        // Only re-render if not currently dragging to prevent flashing
                        if (!this.isDragging) {
                            this.render();
                        }
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        console.log('Failed to load logo:', logoUrl);
                        // Try loading from assets folder if it's a simple filename
                        if (!logoUrl.startsWith('http') && !logoUrl.startsWith('data:')) {
                            const assetPath = `assets/logos/${logoUrl}`;
                            img.src = assetPath;
                        } else {
                            resolve(null);
                        }
                    };
                    
                    // If it's a simple filename, try loading from assets folder first
                    if (!logoUrl.startsWith('http') && !logoUrl.startsWith('data:')) {
                        img.src = `assets/logos/${logoUrl}`;
                    } else {
                        img.src = logoUrl;
                    }
                });
            }

            render() {
                // Save context state
                this.ctx.save();
                
                // Clear canvas (transparent background)
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw circles
                if (this.showCircles) {
                    this.drawCircles();
                }
                
                // Draw connections first (so they appear behind cards)
                this.drawConnections();
                
                // Draw cards - selected cards last so they appear on top
                const unselectedCards = this.cards.filter(card => !this.selectedCards.includes(card));
                const selectedCards = this.cards.filter(card => this.selectedCards.includes(card));
                
                unselectedCards.forEach(card => this.drawCard(card));
                selectedCards.forEach(card => this.drawCard(card));
                
                // Restore context state
                this.ctx.restore();
            }

            drawCircles() {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                // Move circles higher - use 40% from top instead of center
                const centerY = rect.height * 0.4;
                const radius = this.circleRadius;
                const offset = this.centerDistance;

                const circles = [
                    { x: centerX - offset, y: centerY - offset/2, label: 'HRIS', color: 'rgba(59, 130, 246, 0.1)' },
                    { x: centerX + offset, y: centerY - offset/2, label: 'Payroll', color: 'rgba(16, 185, 129, 0.1)' },
                    { x: centerX, y: centerY + offset, label: 'Expense', color: 'rgba(239, 68, 68, 0.1)' }
                ];

                circles.forEach(circle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = circle.color;
                    this.ctx.strokeStyle = circle.color.replace('0.1', '0.6');
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(circle.x, circle.y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.restore();

                    // Smart label positioning at circle edges
                    this.ctx.fillStyle = '#374151';
                    this.ctx.font = 'bold 16px Inter, sans-serif';
                    
                    let labelX, labelY, textAlign, textBaseline;
                    
                    if (circle.label === 'HRIS') {
                        // Left circle - label on left edge
                        labelX = circle.x - radius - 20;
                        labelY = circle.y;
                        textAlign = 'right';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Payroll') {
                        // Right circle - label on right edge  
                        labelX = circle.x + radius + 20;
                        labelY = circle.y;
                        textAlign = 'left';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Expense') {
                        // Bottom circle - label on bottom edge
                        labelX = circle.x;
                        labelY = circle.y + radius + 25;
                        textAlign = 'center';
                        textBaseline = 'top';
                    }
                    
                    this.ctx.textAlign = textAlign;
                    this.ctx.textBaseline = textBaseline;
                    
                    // Pixel-perfect label positioning
                    const pixelX = Math.round(labelX);
                    const pixelY = Math.round(labelY);
                    this.ctx.fillText(circle.label, pixelX, pixelY);
                });
            }

            drawCard(card) {
                const isSelected = this.selectedCards.includes(card);
                const isHovered = this.hoveredCard === card;
                const x = card.x - this.cardSize / 2;
                const y = card.y - this.cardSize / 2;

                // Special handling for Point A cards - only show if global toggle is on OR if hovered
                if (card.isVersion === 'A') {
                    if (!this.showPointA && !isHovered) {
                        return; // Don't draw Point A cards unless globally enabled or hovered
                    }
                }

                this.ctx.save();
                
                // Apply transparency for A cards
                if (card.isVersion === 'A') {
                    this.ctx.globalAlpha = 0.5;
                } else if (card.opacity) {
                    this.ctx.globalAlpha = card.opacity;
                }

                // Enhanced shadow effects
                if (isSelected) {
                    // Selected cards get a stronger shadow
                    this.ctx.shadowColor = 'rgba(59, 130, 246, 0.3)';
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowOffsetY = 4;
                } else if (isHovered) {
                    // Hovered cards get a subtle lift effect
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetY = 3;
                } else {
                    // Default shadow for unselected cards
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetY = 2;
                }

                // White background
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                this.ctx.fill();

                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;

                // Blue border if selected
                if (isSelected) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                    this.ctx.stroke();
                }

                // Draw logo if available, otherwise show initials
                const logo = this.loadedLogos.get(card.logo);
                if (logo && card.logo) {
                    // Draw logo centered in card
                    const logoSize = this.cardSize * 0.6;
                    const logoX = card.x - logoSize / 2;
                    const logoY = card.y - logoSize / 2;
                    
                    this.ctx.drawImage(logo, logoX, logoY, logoSize, logoSize);
                } else {
                    // Company initials - crisp text rendering
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.font = `bold ${Math.max(14, this.cardSize * 0.25)}px Inter, sans-serif`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const initials = card.company
                        .split(' ')
                        .filter(word => word.length > 0)
                        .slice(0, 2)
                        .map(word => word[0].toUpperCase())
                        .join('');
                    
                    // Ensure pixel-perfect text positioning
                    const textX = Math.round(card.x);
                    const textY = Math.round(card.y);
                    this.ctx.fillText(initials, textX, textY);
                }
                
                // Draw directional arrows for Point B cards (no badges)
                if (card.isVersion === 'B') {
                    this.drawPointBArrow(card);
                }
                
                // Show company label on hover
                if (isHovered) {
                    this.drawHoverLabel(card);
                }
                
                this.ctx.restore();
            }

            drawHoverLabel(card) {
                this.ctx.save();
                
                // Label position below the card
                const labelY = card.y + this.cardSize / 2 + 15;
                
                // Measure text for background
                this.ctx.font = '14px Inter, sans-serif';
                const textWidth = this.ctx.measureText(card.company).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 24;
                
                // Draw background with shadow
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                this.ctx.shadowBlur = 4;
                this.ctx.shadowOffsetY = 2;
                
                this.ctx.fillStyle = '#1e293b';
                this.ctx.beginPath();
                this.roundRect(
                    card.x - bgWidth / 2,
                    labelY - bgHeight / 2,
                    bgWidth,
                    bgHeight,
                    6
                );
                this.ctx.fill();
                
                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;
                
                // Draw text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(card.company, card.x, labelY);
                
                this.ctx.restore();
            }

            drawPointBArrow(card) {
                this.ctx.save();
                
                // Position arrow at bottom-right of card
                const arrowX = card.x + this.cardSize / 2 - 12;
                const arrowY = card.y + this.cardSize / 2 - 12;
                
                // Draw arrow pointing right and down (southeast direction)
                this.ctx.fillStyle = '#10b981'; // Green color
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 1;
                
                // Arrow shape
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX - 6, arrowY - 3);
                this.ctx.lineTo(arrowX + 3, arrowY);
                this.ctx.lineTo(arrowX - 6, arrowY + 3);
                this.ctx.lineTo(arrowX - 3, arrowY);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // Second arrow for double-arrow effect
                this.ctx.beginPath();
                this.ctx.moveTo(arrowX - 2, arrowY - 3);
                this.ctx.lineTo(arrowX + 7, arrowY);
                this.ctx.lineTo(arrowX - 2, arrowY + 3);
                this.ctx.lineTo(arrowX + 1, arrowY);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                this.ctx.restore();
            }



            drawConnections() {
                this.connections.forEach(conn => {
                    const startCard = this.cards.find(c => c.id === conn.fromId);
                    const endCard = this.cards.find(c => c.id === conn.toId);
                    
                    if (startCard && endCard) {
                        this.drawConnection(startCard, endCard);
                    }
                });
            }

            drawConnection(startCard, endCard) {
                // Calculate edge-to-edge connection points instead of center-to-center
                const centerAngle = Math.atan2(endCard.y - startCard.y, endCard.x - startCard.x);
                const cardRadius = this.cardSize / 2;
                
                // Start point: edge of start card towards end card
                const startX = startCard.x + Math.cos(centerAngle) * cardRadius;
                const startY = startCard.y + Math.sin(centerAngle) * cardRadius;
                
                // End point: edge of end card towards start card
                const endX = endCard.x - Math.cos(centerAngle) * cardRadius;
                const endY = endCard.y - Math.sin(centerAngle) * cardRadius;
                
                this.ctx.save();
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                // Draw curved connector
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                
                // Create a nice curve
                const distance = Math.sqrt(
                    Math.pow(endX - startX, 2) + 
                    Math.pow(endY - startY, 2)
                );
                const curvature = Math.min(50, distance * 0.3);
                
                // Calculate control points for a smooth curve
                const angle = Math.atan2(endY - startY, endX - startX);
                const perpAngle = angle + Math.PI / 2;
                
                const controlX1 = startX + Math.cos(angle) * distance * 0.3 + Math.cos(perpAngle) * curvature;
                const controlY1 = startY + Math.sin(angle) * distance * 0.3 + Math.sin(perpAngle) * curvature;
                const controlX2 = endX - Math.cos(angle) * distance * 0.3 + Math.cos(perpAngle) * curvature;
                const controlY2 = endY - Math.sin(angle) * distance * 0.3 + Math.sin(perpAngle) * curvature;
                
                this.ctx.bezierCurveTo(
                    controlX1, controlY1,
                    controlX2, controlY2,
                    endX, endY
                );
                
                this.ctx.stroke();
                
                // Draw arrow at end - now visible since line ends at card edge
                this.ctx.setLineDash([]);
                const arrowAngle = Math.atan2(endY - controlY2, endX - controlX2);
                const arrowLength = 12;
                
                this.ctx.beginPath();
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(arrowAngle - Math.PI / 6),
                    endY - arrowLength * Math.sin(arrowAngle - Math.PI / 6)
                );
                this.ctx.moveTo(endX, endY);
                this.ctx.lineTo(
                    endX - arrowLength * Math.cos(arrowAngle + Math.PI / 6),
                    endY - arrowLength * Math.sin(arrowAngle + Math.PI / 6)
                );
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            roundRect(x, y, width, height, radius) {
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
            }

            initializeCleanCanvas() {
                // Preload all logos from assets
                this.preloadAllLogos();
            }

            preloadAllLogos() {
                // List of all available logos
                const logos = [
                    { file: 'adp.svg', name: 'ADP' },
                    { file: 'amp.svg', name: 'AMP' },
                    { file: 'bamboohr.svg', name: 'BambooHR' },
                    { file: 'brex.svg', name: 'Brex' },
                    { file: 'deel.svg', name: 'Deel' },
                    { file: 'factorial.svg', name: 'Factorial' },
                    { file: 'hibob.svg', name: 'HiBob' },
                    { file: 'justworks.svg', name: 'JustWorks' },
                    { file: 'lattice.svg', name: 'Lattice' },
                    { file: 'paychex.svg', name: 'Paychex' },
                    { file: 'paycom.svg', name: 'Paycom' },
                    { file: 'paylocity.svg', name: 'Paylocity' },
                    { file: 'personio.svg', name: 'Personio' },
                    { file: 'pleo.svg', name: 'Pleo' },
                    { file: 'ramp.svg', name: 'Ramp' },
                    { file: 'remote.svg', name: 'Remote' },
                    { file: 'revolut.svg', name: 'Revolut' },
                    { file: 'rippling.svg', name: 'Rippling' },
                    { file: 'spendesk.svg', name: 'Spendesk' },
                    { file: 'swile.svg', name: 'Swile' },
                    { file: 'teamtailor.svg', name: 'Teamtailor' },
                    { file: 'workable.svg', name: 'Workable' },
                    { file: 'workday.svg', name: 'Workday' }
                ];

                // Get canvas dimensions
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height * 0.4;

                // Create a grid layout for the cards
                const cardsPerRow = 8;
                const spacing = this.cardSize + 20;
                const startX = centerX - ((Math.min(cardsPerRow, logos.length) - 1) * spacing) / 2;
                const startY = centerY - 100;

                // Create cards for each logo
                logos.forEach((logo, index) => {
                    const row = Math.floor(index / cardsPerRow);
                    const col = index % cardsPerRow;
                    
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;

                    this.createCard({
                        company: logo.name,
                        logo: logo.file,
                        x: x,
                        y: y
                    });
                });

                this.render();
            }

            async setupStorageBucket() {
                try {
                    console.log('📁 Setting up logos storage bucket...');
                    
                    // First, list all buckets to see what exists
                    const { data: buckets, error: listError } = await this.supabase.storage.listBuckets();
                    
                    if (listError) {
                        throw new Error(`Cannot list buckets: ${listError.message}`);
                    }
                    
                    console.log('📋 Existing buckets:', buckets.map(b => b.name));
                    
                    const logosBucket = buckets.find(bucket => bucket.name === 'logos');
                    
                    if (!logosBucket) {
                        if (SKIP_BUCKET_CREATION) {
                            console.log('⚠️ Logos bucket missing but skipping creation due to RLS. Please create manually.');
                            console.log('📋 MANUAL SETUP REQUIRED:');
                            console.log('1. Go to Supabase → Storage');
                            console.log('2. Create bucket named "logos"');
                            console.log('3. Make it public');
                            console.log('4. Refresh this page');
                            throw new Error('Logos bucket does not exist. Please create it manually in Supabase.');
                        } else {
                            console.log('📁 Creating new logos bucket...');
                            
                            // Create bucket with proper settings and no RLS
                            const { data: createData, error: createError } = await this.supabase.storage.createBucket('logos', {
                                public: true,
                                allowedMimeTypes: ['image/svg+xml', 'image/png', 'image/jpeg'],
                                fileSizeLimit: 10485760 // 10MB
                            });

                            if (createError) {
                                throw new Error(`Bucket creation failed: ${createError.message}`);
                            }
                            
                            console.log('✅ Logos bucket created:', createData);
                        }
                    } else {
                        console.log('✅ Logos bucket already exists');
                    }
                    
                    // Test bucket accessibility
                    const { data: testList, error: testError } = await this.supabase.storage
                        .from('logos')
                        .list('', { limit: 1 });
                        
                    if (testError) {
                        throw new Error(`Bucket access test failed: ${testError.message}`);
                    }
                    
                    console.log('✅ Bucket is accessible');
                    
                } catch (error) {
                    throw new Error(`Storage setup failed: ${error.message}`);
                }
            }

            async testStorageUpload() {
                try {
                    // Create a tiny test SVG
                    const testSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="3" fill="red"/></svg>';
                    const blob = new Blob([testSVG], { type: 'image/svg+xml' });
                    const testFileName = `test-${Date.now()}.svg`;
                    
                    // Try to upload
                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(testFileName, blob, {
                            cacheControl: '3600',
                            upsert: true,
                            contentType: 'image/svg+xml'
                        });

                    if (uploadError) {
                        throw new Error(`Test upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(testFileName);

                    console.log('📤 Test file uploaded:', urlData.publicUrl);

                    // Clean up test file
                    await this.supabase.storage
                        .from('logos')
                        .remove([testFileName]);
                        
                    console.log('🧹 Test file cleaned up');

                } catch (error) {
                    throw new Error(`Storage test failed: ${error.message}`);
                }
            }

            async uploadLogoToStorage(file) {
                if (!this.supabase || !this.isConnected) {
                    throw new Error('Supabase not connected');
                }

                try {
                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const extension = file.name.split('.').pop() || (file.type.includes('svg') ? 'svg' : 'png');
                    const fileName = `logo-${timestamp}-${randomId}.${extension}`;

                    console.log('📤 UPLOADING:', fileName, 'Size:', file.size, 'Type:', file.type);

                    // Upload with proper options
                    const uploadOptions = {
                        cacheControl: '3600',
                        upsert: true // Allow overwrite to avoid conflicts
                    };

                    // Set correct content type
                    if (file.type.includes('svg')) {
                        uploadOptions.contentType = 'image/svg+xml';
                    } else if (file.type.includes('png')) {
                        uploadOptions.contentType = 'image/png';
                    }

                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, file, uploadOptions);

                    if (uploadError) {
                        console.error('💥 UPLOAD ERROR:', uploadError);
                        throw new Error(`Upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('🎉 UPLOAD SUCCESS:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('💥 LOGO UPLOAD COMPLETELY FAILED:', error);
                    throw error;
                }
            }

            async uploadSVGCodeToStorage(svgCode) {
                if (!this.supabase || !this.isConnected) {
                    throw new Error('Supabase not connected');
                }

                try {
                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const fileName = `svg-${timestamp}-${randomId}.svg`;

                    console.log('📤 UPLOADING SVG CODE:', fileName, 'Length:', svgCode.length);

                    // Create blob from SVG code with proper MIME type
                    const blob = new Blob([svgCode], { type: 'image/svg+xml' });

                    // Upload to Supabase Storage
                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, blob, {
                            cacheControl: '3600',
                            upsert: true,
                            contentType: 'image/svg+xml'
                        });

                    if (uploadError) {
                        console.error('💥 SVG UPLOAD ERROR:', uploadError);
                        throw new Error(`SVG upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('🎉 SVG UPLOAD SUCCESS:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('💥 SVG UPLOAD COMPLETELY FAILED:', error);
                    throw error;
                }
            }



            exportCanvas() {
                const link = document.createElement('a');
                link.download = 'business-cards.png';
                link.href = this.canvas.toDataURL();
                link.click();
                // No notification needed for export
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => notification.remove(), 3000);
            }

            async testConnection() {
                console.log('🧪 TESTING SUPABASE CONNECTION...');
                this.updateStatus('connected', 'Testing connection...');
                
                try {
                    // Test 1: Basic Supabase client creation
                    console.log('🔗 Test 1: Creating Supabase client...');
                    const testClient = supabase.createClient(supabaseConfig.url, supabaseConfig.key);
                    
                    // Test 2: Check if table exists and has correct structure
                    console.log('📋 Test 2: Checking table structure...');
                    const { data: tableData, error: tableError } = await testClient
                        .from('canvas_data')
                        .select('id, cards, connections, settings, updated_at')
                        .limit(1);
                    
                    if (tableError) {
                        console.error('❌ Table test failed:', tableError);
                        
                        if (tableError.code === '42P01' || tableError.code === 'PGRST116') {
                            this.updateStatus('disconnected', 'Database table missing');
                            this.showNotification('Database table missing! Check console for setup instructions.', 'error');
                            await this.createSupabaseTable();
                            return;
                        } else {
                            throw tableError;
                        }
                    }
                    
                    console.log('✅ Table structure OK:', tableData);
                    
                    // Test 3: Try a test write
                    console.log('💾 Test 3: Testing write permissions...');
                    const testData = {
                        id: 'shared-canvas',
                        cards: this.cards,
                        connections: this.connections,
                        settings: {
                            circleRadius: this.circleRadius,
                            centerDistance: this.centerDistance,
                            cardSize: this.cardSize,
                            showCircles: this.showCircles
                        },
                        updated_at: new Date().toISOString()
                    };
                    
                    const { error: writeError } = await testClient
                        .from('canvas_data')
                        .upsert(testData, { onConflict: 'id' });
                    
                    if (writeError) {
                        console.error('❌ Write test failed:', writeError);
                        throw writeError;
                    }
                    
                    console.log('✅ Write test OK');
                    
                    // Test 4: Try real-time subscription
                    console.log('📡 Test 4: Testing real-time...');
                    const testChannel = testClient
                        .channel('test-channel')
                        .on('postgres_changes',
                            { event: '*', schema: 'public', table: 'canvas_data' },
                            (payload) => console.log('📡 Real-time test received:', payload)
                        )
                        .subscribe((status) => {
                            console.log('📡 Real-time subscription status:', status);
                        });
                    
                    // Clean up test channel after 5 seconds
                    setTimeout(() => {
                        testChannel.unsubscribe();
                        console.log('🧹 Test channel cleaned up');
                    }, 5000);
                    
                    // All tests passed!
                    this.supabase = testClient;
                    this.isConnected = true;
                    this.updateStatus('connected', 'All tests passed! ✓');
                    this.showNotification('Sync connection working perfectly! 🎉', 'success');
                    
                    // Restart real-time subscription
                    this.setupRealTimeSubscription();
                    
                } catch (error) {
                    console.error('❌ Connection test failed:', error);
                    this.updateStatus('disconnected', 'Test failed: ' + error.message.substring(0, 20));
                    this.showNotification('Sync test failed: ' + error.message, 'error');
                }
            }

        }

        // Global functions for onclick handlers
        let app;
        let uploadedLogoData = null; // Store uploaded logo data

        function openAddCardModal() {
            document.getElementById('addCardModal').classList.add('show');
            setupFileUpload();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            if (modalId === 'addCardModal') {
                resetFileUpload();
            }
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const fileInput = document.getElementById('logoFileInput');
            const uploadContent = uploadArea.querySelector('.upload-content');
            
            // Click to upload
            uploadArea.addEventListener('click', () => {
                if (!uploadArea.querySelector('.logo-preview').style.display || 
                    uploadArea.querySelector('.logo-preview').style.display === 'none') {
                    fileInput.click();
                }
            });
            
            // File input change
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Paste SVG code
            uploadArea.addEventListener('paste', handlePaste);
            uploadArea.setAttribute('tabindex', '0'); // Make it focusable for paste
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            
            const files = Array.from(e.dataTransfer.files);
            const text = e.dataTransfer.getData('text');
            
            if (files.length > 0) {
                const file = files.find(f => f.type.includes('svg') || f.type.includes('png'));
                if (file) {
                    await processFile(file);
                }
            } else if (text && (text.includes('<svg') || text.startsWith('data:image'))) {
                await processSVGCode(text);
            }
        }

        async function handlePaste(e) {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            if (text && text.includes('<svg')) {
                await processSVGCode(text);
            }
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                await processFile(file);
            }
        }

        async function processFile(file) {
            if (!file.type.includes('svg') && !file.type.includes('png')) {
                app.showNotification('Please upload SVG or PNG files only', 'error');
                return;
            }
            
            const uploadArea = document.getElementById('logoUploadArea');
            
            try {
                // For local mode, just use data URL
                const reader = new FileReader();
                reader.onload = (e) => {
                    showLogoPreview(e.target.result);
                    uploadedLogoData = e.target.result;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error processing file:', error);
                app.showNotification('Error processing logo file', 'error');
            }
        }

        async function processSVGCode(svgCode) {
            try {
                // Clean and validate SVG
                const cleanSVG = svgCode.trim();
                if (!cleanSVG.includes('<svg')) {
                    throw new Error('Invalid SVG');
                }
                
                // For local mode, just use data URL
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(cleanSVG);
                showLogoPreview(dataUrl);
                uploadedLogoData = dataUrl;
            } catch (error) {
                app.showNotification('Invalid SVG code', 'error');
            }
        }

        function showLogoPreview(dataUrl) {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const previewImg = document.getElementById('logoPreviewImg');
            
            uploadContent.style.display = 'none';
            preview.style.display = 'block';
            previewImg.src = dataUrl;
        }

        function removeLogo() {
            resetFileUpload();
            uploadedLogoData = null;
            // Also reset the dropdown
            document.getElementById('logoSelect').value = '';
        }

        function handleLogoSelect() {
            const select = document.getElementById('logoSelect');
            const selectedLogo = select.value;
            
            if (selectedLogo) {
                // Show preview using local asset
                showLogoPreview(`assets/logos/${selectedLogo}`);
                uploadedLogoData = selectedLogo; // Just store the filename
            } else {
                removeLogo();
            }
        }

        function resetFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const fileInput = document.getElementById('logoFileInput');
            const logoSelect = document.getElementById('logoSelect');
            
            uploadContent.style.display = 'block';
            preview.style.display = 'none';
            fileInput.value = '';
            logoSelect.value = '';
            uploadedLogoData = null;
        }

        function addBusinessCard() {
            const companyName = document.getElementById('companyName').value.trim();

            if (!companyName) {
                app.showNotification('Please enter a company name', 'error');
                return;
            }

            if (!app.clickPosition.x && !app.clickPosition.y) {
                app.clickPosition = { x: 400, y: 300 }; // Default position
            }

            app.createCard({
                company: companyName,
                logo: uploadedLogoData, // Use uploaded logo data
                x: app.clickPosition.x,
                y: app.clickPosition.y
            });

            app.render();
            closeModal('addCardModal');
            // No notification needed for adding cards
            
            // Clear form
            document.getElementById('companyName').value = '';
            resetFileUpload();
        }

        function addPointBToSelected() {
            if (app) {
                app.addPointB();
            }
        }

        function testConnection() {
            if (app) {
                app.testConnection();
            }
        }

        function exportCanvas() {
            app.exportCanvas();
        }

        function toggleControlsModal() {
            document.getElementById('controlsModal').classList.add('show');
        }



        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 BUSINESS CARD CANVAS STARTING...');
            console.log('');
            console.log('📊 DIAGNOSTIC INFO:');
            console.log('- Supabase URL:', supabaseConfig.url);
            console.log('- Key length:', supabaseConfig.key.length, 'chars');
            console.log('- Browser:', navigator.userAgent.split(' ').pop());
            console.log('- Storage available:', 'localStorage' in window);
            console.log('');
            
            app = new BusinessCardCanvas();
            
            // Style the controls FAB
            const controlsFab = document.getElementById('controlsFab');
            controlsFab.className = 'floating-button controls';
            
            // Setup control sliders and checkbox
            const radiusSlider = document.getElementById('radiusSlider');
            const distanceSlider = document.getElementById('distanceSlider');
            const cardSizeSlider = document.getElementById('cardSizeSlider');
            const radiusValue = document.getElementById('radiusValue');
            const distanceValue = document.getElementById('distanceValue');
            const cardSizeValue = document.getElementById('cardSizeValue');
            const showCirclesCheckbox = document.getElementById('showCirclesCheckbox');
            const showPointACheckbox = document.getElementById('showPointACheckbox');
            
            // Update UI with loaded values
            app.updateControlsUI();
            
            radiusSlider.addEventListener('input', (e) => {
                app.circleRadius = parseInt(e.target.value);
                radiusValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            distanceSlider.addEventListener('input', (e) => {
                app.centerDistance = parseInt(e.target.value);
                distanceValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            cardSizeSlider.addEventListener('input', (e) => {
                app.cardSize = parseInt(e.target.value);
                cardSizeValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            showCirclesCheckbox.addEventListener('change', (e) => {
                app.showCircles = e.target.checked;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            showPointACheckbox.addEventListener('change', (e) => {
                app.showPointA = e.target.checked;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            console.log('✅ Business Card Canvas ready with real-time collaboration');
            console.log('🌐 Multi-device collaboration: Supabase-powered');
            console.log('💾 Auto-save: Instant across all devices');
            console.log('');
            console.log('🔧 SYNC TROUBLESHOOTING:');
            console.log('1. Check the status indicator (top-right corner)');
            console.log('2. Click the orange sync test button to diagnose issues');
            console.log('3. Open browser console to see detailed error messages');
            console.log('4. If table is missing, follow the SQL setup instructions');
            console.log('');
            
            // Setup instructions
            setTimeout(() => {
                if (!app.isConnected) {
                    console.log('');
                    console.log('🚀 SETUP SUPABASE FOR REAL COLLABORATION:');
                    console.log('1. Go to https://supabase.com and create a project');
                    console.log('2. Click the orange sync test button for setup instructions');
                    console.log('3. Update supabaseConfig with your project URL and anon key');
                    console.log('4. Refresh and enjoy real multi-device collaboration! 🎉');
                    console.log('');
                }
            }, 2000);
        });
    </script>
</body>
</html> 