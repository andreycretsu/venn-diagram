<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Card Canvas</title>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ¯</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-border: #e2e8f0;
            --color-text-primary: #1e293b;
            --color-primary: #3b82f6;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --radius-lg: 12px;
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--color-background);
            color: var(--color-text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--color-background);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--color-background);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: var(--color-background);
            cursor: default;
        }

        .floating-controls {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            z-index: 1000;
        }

        .floating-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: var(--color-primary);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }

        .floating-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.2);
        }

        .floating-button.success { background: #10b981; }
        .floating-button.active { background: #8b5cf6; }
        .floating-button.inactive { background: #64748b; }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-md);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--color-text-primary);
        }

        .form-group {
            margin-bottom: var(--space-md);
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text-primary);
            border: 1px solid var(--color-border);
        }

        .modal-footer {
            display: flex;
            gap: var(--space-md);
            justify-content: flex-end;
            margin-top: var(--space-lg);
        }

        .notification {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            z-index: 3000;
            max-width: 300px;
        }

        .notification.success { border-left: 4px solid #10b981; }
        .notification.error { border-left: 4px solid #ef4444; }
        .notification.info { border-left: 4px solid var(--color-primary); }

        .floating-button.controls { background: #8b5cf6; }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            left: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            font-size: 14px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulseSave {
            0% { 
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }
            100% { 
                transform: scale(1);
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            }
        }

        .floating-button.pulse {
            animation: pulseSave 1.5s ease-in-out infinite;
        }

        .file-upload-area {
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--color-surface);
        }

        .file-upload-area:hover {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .file-upload-area.drag-over {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .upload-content i {
            font-size: 24px;
            color: var(--color-primary);
            margin-bottom: 8px;
        }

        .upload-content p {
            margin: 4px 0;
            font-size: 14px;
        }

        .upload-hint {
            color: #64748b;
            font-size: 12px !important;
        }

        .logo-preview {
            position: relative;
            max-width: 120px;
            margin: 0 auto;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 8px;
            background: white;
        }

        .logo-preview img {
            width: 100%;
            height: auto;
            max-height: 60px;
            object-fit: contain;
        }

        .remove-logo {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 1000;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
        }

        .control-group {
            margin-bottom: var(--space-md);
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--color-text-primary);
        }

        .control-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .control-slider {
            width: 100%;
            height: 4px;
            background: var(--color-border);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .control-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <!-- Circle Controls Modal -->
        <div class="modal" id="controlsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Circle Controls</h2>
                    <button class="modal-close" onclick="closeModal('controlsModal')">Ã—</button>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Radius: <span id="radiusValue">200</span>px</label>
                    <input type="range" id="radiusSlider" min="50" max="500" value="200" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Distance: <span id="distanceValue">200</span>px</label>
                    <input type="range" id="distanceSlider" min="50" max="300" value="200" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Card Size: <span id="cardSizeValue">64</span>px</label>
                    <input type="range" id="cardSizeSlider" min="40" max="120" value="64" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showCirclesCheckbox" checked> Show Circles
                    </label>
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="closeModal('controlsModal')">Done</button>
                </div>
            </div>
        </div>

        <!-- Auto-save Status -->
        <div class="autosave-status" id="autosaveStatus">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Checking connection...</span>
        </div>

        <div class="floating-controls">
            <button class="floating-button" onclick="openAddCardModal()" title="Add Card">
                <i class="fas fa-plus"></i>
            </button>
            <button class="floating-button" onclick="toggleDuplicateMode()" title="Create A/B Mode" id="duplicateFab">
                <i class="fas fa-copy"></i>
            </button>
            <button class="floating-button" onclick="toggleEditABMode()" title="Edit A/B Points" id="editABFab">
                <i class="fas fa-edit"></i>
            </button>
            <button class="floating-button success" onclick="saveEditChanges()" title="Save Changes" id="saveEditFab" style="display: none;">
                <i class="fas fa-save"></i>
            </button>
            <button class="floating-button" onclick="toggleControlsModal()" title="Circle Controls" id="controlsFab">
                <i class="fas fa-sliders-h"></i>
            </button>
            <button class="floating-button success" onclick="exportCanvas()" title="Export">
                <i class="fas fa-download"></i>
            </button>
        </div>
    </div>

    <!-- Add Card Modal -->
    <div class="modal" id="addCardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Business Card</h2>
                <button class="modal-close" onclick="closeModal('addCardModal')">Ã—</button>
            </div>
            
            <div class="form-group">
                <label class="form-label">Company Name</label>
                <input type="text" id="companyName" class="form-input" placeholder="Enter company name">
            </div>
            
            <div class="form-group">
                <label class="form-label">Logo Selection</label>
                <select id="logoSelect" class="form-select" onchange="handleLogoSelect()">
                    <option value="">-- Select from available logos --</option>
                    <option value="adp.svg">ADP</option>
                    <option value="amp.svg">AMP</option>
                    <option value="bamboohr.svg">BambooHR</option>
                    <option value="brex.svg">Brex</option>
                    <option value="deel.svg">Deel</option>
                    <option value="factorial.svg">Factorial</option>
                    <option value="hibob.svg">HiBob</option>
                    <option value="justworks.svg">JustWorks</option>
                    <option value="lattice.svg">Lattice</option>
                    <option value="paychex.svg">Paychex</option>
                    <option value="paycom.svg">Paycom</option>
                    <option value="paylocity.svg">Paylocity</option>
                    <option value="personio.svg">Personio</option>
                    <option value="pleo.svg">Pleo</option>
                    <option value="ramp.svg">Ramp</option>
                    <option value="remote.svg">Remote</option>
                    <option value="revolut.svg">Revolut</option>
                    <option value="rippling.svg">Rippling</option>
                    <option value="spendesk.svg">Spendesk</option>
                    <option value="swile.svg">Swile</option>
                    <option value="teamtailor.svg">Teamtailor</option>
                    <option value="workable.svg">Workable</option>
                    <option value="workday.svg">Workday</option>
                </select>
            </div>
            
            <div class="form-group">
                <label class="form-label">Or Upload Custom Logo</label>
                <div class="file-upload-area" id="logoUploadArea">
                    <div class="upload-content">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Drag & drop SVG/PNG files or SVG code here</p>
                        <p class="upload-hint">or click to browse</p>
                    </div>
                    <input type="file" id="logoFileInput" accept=".svg,.png,image/svg+xml,image/png" style="display: none;">
                    <div class="logo-preview" id="logoPreview" style="display: none;">
                        <img id="logoPreviewImg" alt="Logo preview">
                        <button type="button" class="remove-logo" onclick="removeLogo()">&times;</button>
                    </div>
                </div>
            </div>
            

            
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addCardModal')">Cancel</button>
                <button class="btn btn-primary" onclick="addBusinessCard()">Add Card</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        // REAL Supabase setup - configured with your project
        const supabaseConfig = {
            url: 'https://djoboiwyethvkswrhlsp.supabase.co',
            key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRqb2JvaXd5ZXRodmtzd3JobHNwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk0NjYzMDYsImV4cCI6MjA2NTA0MjMwNn0.69O6lLpFYkh7Y9fIMCeAq81b-TVC_uN_XRn34SVWCYI'
        };

        // Skip bucket creation if we can't create it due to RLS
        const SKIP_BUCKET_CREATION = true;

        // Global Supabase client
        let supabaseClient = null;

        // Business Card Canvas with REAL Supabase
        class BusinessCardCanvas {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cards = [];
                this.selectedCards = [];
                this.clickPosition = { x: 0, y: 0 };
                this.showCircles = true;
                this.isDragging = false;
                this.dragStartPos = null;
                this.dragOffset = null;
                this.hoveredCard = null;
                this.loadedLogos = new Map();
                this.animationFrameId = null;
                this.connections = [];
                this.isConnecting = false;
                this.connectionStart = null;
                this.lastMousePos = { x: 0, y: 0 };
                this.duplicateMode = false;
                this.cardToDuplicate = null;
                this.editABMode = false;
                this.editingCard = null;
                this.draggingPoint = null;
                this.hasUnsavedChanges = false;
                this.editStartState = null;
                this.hasChanges = false;
                this.autosaveInterval = null;
                
                this.circleRadius = 200;
                this.centerDistance = 200;
                this.cardSize = 64;
                
                // Real collaboration setup
                this.supabase = null;
                this.subscription = null;
                this.isConnected = false;
                this.isUpdating = false;
                this.dragSaveTimeout = null;
                
                this.init();
            }

            init() {
                // Clear any old localStorage data to start fresh
                localStorage.removeItem('venn-canvas-local');
                console.log('ðŸ§¹ Cleared localStorage - starting with clean canvas');
                
                this.initSupabase();
                this.resizeCanvas();
                this.setupEventListeners();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.render();
            }

            async initSupabase() {
                try {
                    console.log('ðŸ”„ Initializing Supabase for cloud autosave...');
                    
                    // Try to connect to Supabase
                    const connected = await this.connectToSupabase();
                    
                    if (connected) {
                        console.log('âœ… Supabase connected - autosave enabled');
                        this.updateStatus('connected', 'Cloud autosave active');
                        
                        // Load data from Supabase
                        await this.loadFromSupabase();
                        
                        // Set up real-time sync
                        this.setupRealTimeSubscription();
                        
                        // Set up autosave interval
                        this.setupAutosave();
                    } else {
                        // Fallback to localStorage
                        console.log('âš ï¸ Using local storage only');
                        this.updateStatus('disconnected', 'Local storage only');
                        this.loadFromStorage();
                        if (this.cards.length === 0) {
                            this.initializeCleanCanvas();
                        }
                    }
                    
                } catch (error) {
                    console.error('Error in initSupabase:', error);
                    this.loadFromStorage();
                    if (this.cards.length === 0) {
                        this.initializeCleanCanvas();
                    }
                }
            }

            async connectToSupabase() {
                try {
                    supabaseClient = supabase.createClient(supabaseConfig.url, supabaseConfig.key);
                    
                    // Test connection
                    const { data: testData, error: testError } = await supabaseClient
                        .from('canvas_data')
                        .select('id')
                        .limit(1);
                    
                    if (!testError || testError.code === 'PGRST116') {
                        this.supabase = supabaseClient;
                        this.isConnected = true;
                        
                        // Create table if it doesn't exist
                        if (testError && testError.code === 'PGRST116') {
                            await this.createSupabaseTable();
                        }
                        
                        return true;
                    }
                    
                    return false;
                } catch (error) {
                    console.error('Supabase connection failed:', error);
                    return false;
                }
            }

            async createSupabaseTable() {
                // This would normally be done in Supabase dashboard
                // Providing SQL for reference
                console.log(`
                    To enable cloud autosave, create this table in Supabase SQL editor:
                    
                    CREATE TABLE IF NOT EXISTS canvas_data (
                        id text PRIMARY KEY DEFAULT 'shared-canvas',
                        cards jsonb DEFAULT '[]'::jsonb,
                        connections jsonb DEFAULT '[]'::jsonb,
                        settings jsonb DEFAULT '{}'::jsonb,
                        updated_at timestamp with time zone DEFAULT now()
                    );
                    
                    -- Enable real-time
                    ALTER PUBLICATION supabase_realtime ADD TABLE canvas_data;
                    
                    -- Insert initial row
                    INSERT INTO canvas_data (id) VALUES ('shared-canvas')
                    ON CONFLICT (id) DO NOTHING;
                `);
            }

            setupAutosave() {
                // Clear any existing interval
                if (this.autosaveInterval) {
                    clearInterval(this.autosaveInterval);
                }
                
                // Autosave every 3 seconds if there are changes
                this.autosaveInterval = setInterval(() => {
                    if (this.hasChanges && !this.editABMode && !this.isDragging) {
                        this.saveToSupabase();
                        this.hasChanges = false;
                    }
                }, 3000);
                
                // Also save on window blur/unload
                window.addEventListener('blur', () => {
                    if (this.hasChanges && !this.editABMode) {
                        this.saveToSupabase();
                        this.hasChanges = false;
                    }
                });
                
                window.addEventListener('beforeunload', () => {
                    if (this.hasChanges && !this.editABMode) {
                        this.saveToSupabase();
                    }
                });
            }

            updateStatus(status, text) {
                const statusText = document.getElementById('statusText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                statusText.textContent = text;
                this.isConnected = status === 'connected';
                
                if (status === 'connected') {
                    statusText.style.color = '#10b981';
                    statusIndicator.className = 'status-indicator';
                    statusIndicator.style.background = '#10b981';
                } else {
                    statusText.style.color = '#ef4444';
                    statusIndicator.className = 'status-indicator disconnected';
                    statusIndicator.style.background = '#ef4444';
                }
            }

            async loadFromSupabase() {
                if (!this.supabase) return;

                try {
                    console.log('ðŸ“¥ Loading data from Supabase...');
                    
                    const { data, error } = await this.supabase
                        .from('canvas_data')
                        .select('*')
                        .eq('id', 'shared-canvas')
                        .single();

                    if (error) {
                        if (error.code === 'PGRST116') {
                            // No data found, create initial record
                            console.log('ðŸ“ No data found, creating initial record...');
                            await this.createInitialRecord();
                            return;
                        }
                        throw error;
                    }

                    if (data && data.cards) {
                        console.log('ðŸ“¥ Loading saved canvas from cloud...');
                        this.cards = data.cards || [];
                        this.connections = data.connections || [];
                        
                        if (data.settings) {
                            this.circleRadius = data.settings.circleRadius || 200;
                            this.centerDistance = data.settings.centerDistance || 200;
                            this.cardSize = data.settings.cardSize || 64;
                            this.showCircles = data.settings.showCircles !== false;
                            this.updateControlsUI();
                        }
                        
                        // Pre-load all logos
                        this.cards.forEach(card => {
                            if (card.logo) {
                                this.loadLogo(card.logo);
                            }
                        });
                        
                        this.render();
                    } else {
                        // No saved data, start with clean canvas
                        this.initializeCleanCanvas();
                    }
                } catch (error) {
                    console.error('âŒ Error loading from Supabase:', error.message);
                    this.initializeCleanCanvas();
                }
            }



            async createInitialRecord() {
                try {
                    const initialData = {
                        id: 'shared-canvas',
                        cards: [],
                        connections: [],
                        settings: {
                            circleRadius: 200,
                            centerDistance: 200,
                            cardSize: 64,
                            showCircles: true
                        },
                        updated_at: new Date().toISOString()
                    };

                    // Insert only if doesn't exist
                    const { error } = await this.supabase
                        .from('canvas_data')
                        .insert(initialData);

                    if (error && error.code !== '23505') { // 23505 = duplicate key
                        throw error;
                    }
                    
                    console.log('âœ… Created initial Supabase record');
                    this.initializeCleanCanvas();
                } catch (error) {
                    console.error('âŒ Failed to create initial record:', error.message);
                    this.initializeCleanCanvas();
                }
            }

            setupRealTimeSubscription() {
                if (!this.supabase) return;

                console.log('ðŸ”” Setting up real-time subscription...');
                
                // Subscribe to real-time changes
                this.subscription = this.supabase
                    .channel('canvas-realtime')
                    .on('postgres_changes', 
                        { 
                            event: 'UPDATE', 
                            schema: 'public', 
                            table: 'canvas_data',
                            filter: 'id=eq.shared-canvas'
                        },
                        (payload) => {
                            if (!this.isUpdating) {
                                console.log('ðŸ“¡ Received real-time update from another device!');
                                this.handleRealtimeUpdate(payload.new);
                            }
                        }
                    )
                    .subscribe((status) => {
                        console.log('ðŸ“¡ Real-time subscription status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('âœ… Real-time collaboration is ACTIVE!');
                        }
                    });
            }

            handleRealtimeUpdate(data) {
                console.log('ðŸ“¡ INSTANT UPDATE received from another device!', {
                    cards: data.cards?.length || 0,
                    connections: data.connections?.length || 0,
                    isDragging: this.isDragging
                });
                
                // Don't update if we're currently dragging
                if (this.isDragging) {
                    return;
                }
                
                // Update immediately for instant sync
                this.cards = data.cards || [];
                this.connections = data.connections || [];
                if (data.settings) {
                    this.circleRadius = data.settings.circleRadius || 200;
                    this.centerDistance = data.settings.centerDistance || 200;
                    this.cardSize = data.settings.cardSize || 64;
                    this.showCircles = data.settings.showCircles !== false;
                    this.updateControlsUI();
                }
                
                // Pre-load any new logos
                this.cards.forEach(card => {
                    if (card.logo && !this.loadedLogos.has(card.logo)) {
                        this.loadLogo(card.logo);
                    }
                });
                
                this.render();
            }

            async saveToSupabase() {
                if (!this.supabase || !this.isConnected) {
                    console.log('ðŸ’¾ No Supabase connection - saving locally only');
                    this.saveToStorage();
                    return;
                }

                this.isUpdating = true; // Prevent infinite loops
                
                try {
                    const saveData = {
                        id: 'shared-canvas',
                        cards: this.cards,
                        connections: this.connections,
                        settings: {
                            circleRadius: this.circleRadius,
                            centerDistance: this.centerDistance,
                            cardSize: this.cardSize,
                            showCircles: this.showCircles
                        },
                        updated_at: new Date().toISOString()
                    };

                    console.log('ðŸ’¾ Autosaving to cloud...', { 
                        cards: this.cards.length,
                        connections: this.connections.length 
                    });

                    const { error } = await this.supabase
                        .from('canvas_data')
                        .upsert(saveData, { onConflict: 'id' });

                    if (error) {
                        console.error('âŒ Supabase save error:', error);
                        throw error;
                    }

                    // Update status briefly to show save
                    this.updateStatus('connected', 'Saved to cloud âœ“');
                    setTimeout(() => {
                        this.updateStatus('connected', 'Cloud autosave active');
                    }, 2000);

                } catch (error) {
                    console.error('âŒ Save to Supabase failed:', error.message);
                    this.updateStatus('disconnected', 'Sync Failed - Local Only');
                    this.saveToStorage();
                } finally {
                    this.isUpdating = false;
                }
            }

            // Fallback localStorage methods
            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('venn-canvas-local');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.cards = data.cards || [];
                        this.connections = data.connections || [];
                        if (data.settings) {
                            this.circleRadius = data.settings.circleRadius || 200;
                            this.centerDistance = data.settings.centerDistance || 200;
                            this.cardSize = data.settings.cardSize || 64;
                            this.showCircles = data.settings.showCircles !== false;
                            this.updateControlsUI();
                        }
                    }
                } catch (error) {
                    console.log('Error loading local data:', error);
                }
            }

            saveToStorage() {
                const data = {
                    cards: this.cards,
                    connections: this.connections,
                    settings: {
                        circleRadius: this.circleRadius,
                        centerDistance: this.centerDistance,
                        cardSize: this.cardSize,
                        showCircles: this.showCircles
                    }
                };
                localStorage.setItem('venn-canvas-local', JSON.stringify(data));
            }

            updateControlsUI() {
                document.getElementById('radiusSlider').value = this.circleRadius;
                document.getElementById('radiusValue').textContent = this.circleRadius;
                document.getElementById('distanceSlider').value = this.centerDistance;
                document.getElementById('distanceValue').textContent = this.centerDistance;
                document.getElementById('cardSizeSlider').value = this.cardSize;
                document.getElementById('cardSizeValue').textContent = this.cardSize;
                document.getElementById('showCirclesCheckbox').checked = this.showCircles;
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Store current transform
                const currentTransform = this.ctx.getTransform();
                
                // Set actual canvas size for crisp vector rendering
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale canvas back down using CSS
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context so everything draws at correct size
                this.ctx.scale(dpr, dpr);
                
                // Enable crisp text and shape rendering
                this.ctx.textRenderingOptimization = 'optimizeQuality';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Only render if not dragging
                if (!this.isDragging) {
                    this.render();
                }
            }

            setupEventListeners() {
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl+S or Cmd+S to save in edit mode
                    if ((e.ctrlKey || e.metaKey) && e.key === 's' && this.editABMode) {
                        e.preventDefault();
                        if (this.hasUnsavedChanges) {
                            saveEditChanges();
                        }
                    }
                });
                
                // Mouse move for hover effects and dragging
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    this.lastMousePos = mousePos;
                    
                    // If connecting, update the preview line
                    if (this.isConnecting) {
                        this.render();
                        return;
                    }
                    
                    if (this.isDragging && this.draggingPoint && this.editABMode) {
                        // Dragging A/B point in edit mode
                        this.canvas.style.cursor = 'move';
                        
                        if (this.dragOffset) {
                            this.draggingPoint.x = mousePos.x - this.dragOffset[0].x;
                            this.draggingPoint.y = mousePos.y - this.dragOffset[0].y;
                            
                            // Use requestAnimationFrame for smooth rendering
                            if (!this.animationFrameId) {
                                this.animationFrameId = requestAnimationFrame(() => {
                                    this.render();
                                    this.animationFrameId = null;
                                });
                            }
                        }
                    } else if (this.isDragging && this.selectedCards.length > 0 && !this.editABMode) {
                        // Regular card dragging
                        this.canvas.style.cursor = 'grabbing';
                        
                        if (this.dragOffset) {
                            // Update card positions based on mouse position and offset
                            this.selectedCards.forEach((card, index) => {
                                card.x = mousePos.x - this.dragOffset[index].x;
                                card.y = mousePos.y - this.dragOffset[index].y;
                            });
                            
                            // Use requestAnimationFrame for smooth rendering
                            if (!this.animationFrameId) {
                                this.animationFrameId = requestAnimationFrame(() => {
                                    this.render();
                                    this.animationFrameId = null;
                                });
                            }
                        }
                    } else {
                        // Check hover state only when not dragging
                        const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                        if (hoveredCard !== this.hoveredCard) {
                            this.hoveredCard = hoveredCard;
                            
                            if (hoveredCard) {
                                // Show open hand cursor when hovering over card
                                this.canvas.style.cursor = 'grab';
                            } else {
                                // Default cursor when not over card
                                this.canvas.style.cursor = 'default';
                            }
                            
                            // Render only if hover state changed
                            this.render();
                        }
                    }
                });

                // Mouse down to start selection/dragging
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.clickPosition = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    // Handle edit A/B mode
                    if (this.editABMode) {
                        const clickedCard = this.getCardAt(this.clickPosition.x, this.clickPosition.y);
                        
                        // Check if clicking on A or B point
                        if (clickedCard && (clickedCard.isVersion === 'A' || clickedCard.isVersion === 'B')) {
                            this.draggingPoint = clickedCard;
                            this.isDragging = true;
                            this.canvas.style.cursor = 'move';
                            
                            // Calculate offset
                            this.dragOffset = [{
                                x: this.clickPosition.x - clickedCard.x,
                                y: this.clickPosition.y - clickedCard.y
                            }];
                            
                            return;
                        } else if (clickedCard && !clickedCard.isVersion && !this.editingCard) {
                            // Clicking on a regular card - start editing it
                            this.editingCard = clickedCard;
                            this.selectedCards = [clickedCard];
                            app.showNotification('Click to add/move point A, then point B', 'info');
                            this.render();
                            return;
                        } else if (this.editingCard) {
                            // Place or move points
                            const existingA = this.cards.find(c => 
                                c.pairedCardId === this.editingCard.id && c.isVersion === 'A'
                            );
                            const existingB = this.cards.find(c => 
                                c.pairedCardId === (existingA ? existingA.id : null) && c.isVersion === 'B'
                            );
                            
                            if (!existingA) {
                                // Create point A
                                const pointACard = {
                                    id: Date.now() + Math.random(),
                                    company: this.editingCard.company,
                                    logo: this.editingCard.logo,
                                    x: this.clickPosition.x,
                                    y: this.clickPosition.y,
                                    isVersion: 'A',
                                    isHoverOnly: true,
                                    pairedCardId: this.editingCard.id
                                };
                                this.cards.push(pointACard);
                                this.hasUnsavedChanges = true;
                                this.updateSaveButton();
                                app.showNotification('Point A placed. Click to place point B', 'info');
                                this.render();
                                return;
                            } else if (!existingB) {
                                // Create point B
                                const pointBCard = {
                                    id: Date.now() + Math.random(),
                                    company: this.editingCard.company,
                                    logo: this.editingCard.logo,
                                    x: this.clickPosition.x,
                                    y: this.clickPosition.y,
                                    isVersion: 'B',
                                    pairedCardId: existingA.id
                                };
                                this.cards.push(pointBCard);
                                
                                // Create connection
                                this.connections.push({
                                    id: Date.now() + Math.random(),
                                    fromId: existingA.id,
                                    toId: pointBCard.id
                                });
                                
                                // Remove original card
                                const originalIndex = this.cards.findIndex(c => c.id === this.editingCard.id);
                                if (originalIndex > -1) {
                                    this.cards.splice(originalIndex, 1);
                                }
                                
                                this.editingCard = null;
                                this.selectedCards = [];
                                this.hasUnsavedChanges = true;
                                this.updateSaveButton();
                                app.showNotification('A/B points created successfully! Click Save to confirm changes.', 'info');
                                this.render();
                                return;
                            }
                        }
                        
                        // Click on empty space - cancel editing
                        this.editingCard = null;
                        this.selectedCards = [];
                        this.render();
                        return;
                    }
                    
                    // Handle duplicate mode
                    if (this.duplicateMode) {
                        const clickedCard = this.getCardAt(this.clickPosition.x, this.clickPosition.y);
                        
                        if (clickedCard && !this.cardToDuplicate) {
                            // First click - select card to duplicate
                            this.cardToDuplicate = clickedCard;
                            this.selectedCards = [clickedCard];
                            app.showNotification('Now click to place point A (hover version)', 'info');
                            this.render();
                            return;
                        } else if (this.cardToDuplicate && !this.cardToDuplicate.pointAPlaced) {
                            // Second click - place point A
                            const pointACard = {
                                id: Date.now() + Math.random(),
                                company: this.cardToDuplicate.company,
                                logo: this.cardToDuplicate.logo,
                                x: this.clickPosition.x,
                                y: this.clickPosition.y,
                                isVersion: 'A',
                                isHoverOnly: true,
                                pairedCardId: this.cardToDuplicate.id
                            };
                            
                            this.cards.push(pointACard);
                            this.cardToDuplicate.pointAPlaced = true;
                            this.cardToDuplicate.pointAId = pointACard.id;
                            
                            app.showNotification('Now click to place point B', 'info');
                            this.render();
                            return;
                        } else if (this.cardToDuplicate && this.cardToDuplicate.pointAPlaced) {
                            // Third click - place point B
                            const pointBCard = {
                                id: Date.now() + Math.random(),
                                company: this.cardToDuplicate.company,
                                logo: this.cardToDuplicate.logo,
                                x: this.clickPosition.x,
                                y: this.clickPosition.y,
                                isVersion: 'B',
                                pairedCardId: this.cardToDuplicate.pointAId
                            };
                            
                            this.cards.push(pointBCard);
                            
                            // Create connection from A to B
                            this.connections.push({
                                id: Date.now() + Math.random(),
                                fromId: this.cardToDuplicate.pointAId,
                                toId: pointBCard.id
                            });
                            
                            // Remove original card
                            const originalIndex = this.cards.findIndex(c => c.id === this.cardToDuplicate.id);
                            if (originalIndex > -1) {
                                this.cards.splice(originalIndex, 1);
                            }
                            
                            // Reset duplicate mode
                            this.cardToDuplicate = null;
                            this.selectedCards = [];
                            this.hasChanges = true;  // Mark for autosave
                            this.render();
                            return;
                        }
                    }
                    
                    const clickedCard = this.getCardAt(this.clickPosition.x, this.clickPosition.y);
                    if (clickedCard) {
                        // Start dragging
                        this.isDragging = true;
                        this.canvas.style.cursor = 'grabbing';
                        
                        // Select card if not already selected
                        if (!this.selectedCards.includes(clickedCard)) {
                            if (!e.shiftKey) {
                                this.selectedCards = [clickedCard];
                            } else {
                                this.selectedCards.push(clickedCard);
                            }
                        }
                        
                        // Calculate offset for each selected card
                        this.dragOffset = this.selectedCards.map(card => ({
                            x: this.clickPosition.x - card.x,
                            y: this.clickPosition.y - card.y
                        }));
                        
                        this.render();
                    } else {
                        // Clear selection if clicking empty space
                        this.selectedCards = [];
                        this.isDragging = false;
                        this.dragOffset = null;
                        this.render();
                    }
                });

                // Mouse up to end dragging
                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.isDragging) {
                        if (this.editABMode) {
                            // Mark as having unsaved changes instead of auto-saving
                            this.hasUnsavedChanges = true;
                            this.updateSaveButton();
                        } else {
                            // Mark for autosave in normal mode
                            this.hasChanges = true;
                        }
                    }
                    
                    this.isDragging = false;
                    this.dragOffset = null;
                    this.draggingPoint = null;
                    
                    // Reset cursor based on current mode and hover state
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    if (this.editABMode) {
                        this.canvas.style.cursor = 'crosshair';
                    } else {
                        const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                        this.canvas.style.cursor = hoveredCard ? 'grab' : 'default';
                    }
                });

                // Mouse leave to reset cursor
                this.canvas.addEventListener('mouseleave', () => {
                    if (this.isDragging) {
                        if (this.editABMode) {
                            // Mark as unsaved in edit mode
                            this.hasUnsavedChanges = true;
                            this.updateSaveButton();
                        } else {
                            // Save if dragging when leaving canvas in normal mode
                            this.saveToSupabase();
                        }
                    }
                    this.isDragging = false;
                    this.dragOffset = null;
                    this.hoveredCard = null;
                    this.canvas.style.cursor = 'default';
                });
            }

            getCardAt(x, y) {
                return this.cards.find(card => {
                    const dist = Math.sqrt(
                        Math.pow(x - card.x, 2) + Math.pow(y - card.y, 2)
                    );
                    return dist <= this.cardSize / 2;
                });
            }

            getConnectionPointAt(x, y) {
                for (const card of this.cards) {
                    // Check point A (start) - only if card is hovered
                    if (this.hoveredCard === card) {
                        const startPoint = this.getConnectionPoint(card, 'start');
                        const distToStart = Math.sqrt(
                            Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
                        );
                        if (distToStart <= 8) {
                            return { card, type: 'start' };
                        }
                    }
                    
                    // Check point B (end) - always
                    const endPoint = this.getConnectionPoint(card, 'end');
                    const distToEnd = Math.sqrt(
                        Math.pow(x - endPoint.x, 2) + Math.pow(y - endPoint.y, 2)
                    );
                    if (distToEnd <= 8) {
                        return { card, type: 'end' };
                    }
                }
                return null;
            }

            toggleCardSelection(card) {
                const index = this.selectedCards.indexOf(card);
                if (index > -1) {
                    this.selectedCards.splice(index, 1);
                } else {
                    this.selectedCards.push(card);
                }
            }

            createCard(data) {
                const card = {
                    id: Date.now() + Math.random(),
                    company: data.company,
                    logo: data.logo || '',
                    x: data.x,
                    y: data.y
                };
                this.cards.push(card);
                
                // Pre-load logo if provided
                if (card.logo) {
                    this.loadLogo(card.logo);
                }
                
                // Mark for autosave
                this.hasChanges = true;
                
                return card;
            }

            async loadLogo(logoUrl) {
                if (this.loadedLogos.has(logoUrl)) return this.loadedLogos.get(logoUrl);

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        this.loadedLogos.set(logoUrl, img);
                        // Only re-render if not currently dragging to prevent flashing
                        if (!this.isDragging) {
                            this.render();
                        }
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        console.log('Failed to load logo:', logoUrl);
                        // Try loading from assets folder if it's a simple filename
                        if (!logoUrl.startsWith('http') && !logoUrl.startsWith('data:')) {
                            const assetPath = `assets/logos/${logoUrl}`;
                            img.src = assetPath;
                        } else {
                            resolve(null);
                        }
                    };
                    
                    // If it's a simple filename, try loading from assets folder first
                    if (!logoUrl.startsWith('http') && !logoUrl.startsWith('data:')) {
                        img.src = `assets/logos/${logoUrl}`;
                    } else {
                        img.src = logoUrl;
                    }
                });
            }

            render() {
                // Save context state
                this.ctx.save();
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // White background
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw circles
                if (this.showCircles) {
                    this.drawCircles();
                }
                
                // Draw connections first (so they appear behind cards)
                this.drawConnections();
                
                // Always show connections for hover-only cards
                this.drawHoverConnections();
                
                // Draw active connection being created
                if (this.isConnecting && this.connectionStart) {
                    const startPoint = this.getConnectionPoint(this.connectionStart, 'start');
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = this.lastMousePos?.x || 0;
                    const mouseY = this.lastMousePos?.y || 0;
                    
                    this.ctx.save();
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.globalAlpha = 0.5;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startPoint.x, startPoint.y);
                    this.ctx.lineTo(mouseX, mouseY);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
                
                // Draw cards - selected cards last so they appear on top
                const unselectedCards = this.cards.filter(card => !this.selectedCards.includes(card));
                const selectedCards = this.cards.filter(card => this.selectedCards.includes(card));
                
                unselectedCards.forEach(card => this.drawCard(card));
                selectedCards.forEach(card => this.drawCard(card));
                
                // Restore context state
                this.ctx.restore();
            }

            drawCircles() {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                // Move circles higher - use 40% from top instead of center
                const centerY = rect.height * 0.4;
                const radius = this.circleRadius;
                const offset = this.centerDistance;

                const circles = [
                    { x: centerX - offset, y: centerY - offset/2, label: 'HRIS', color: 'rgba(59, 130, 246, 0.1)' },
                    { x: centerX + offset, y: centerY - offset/2, label: 'Payroll', color: 'rgba(16, 185, 129, 0.1)' },
                    { x: centerX, y: centerY + offset, label: 'Expense', color: 'rgba(239, 68, 68, 0.1)' }
                ];

                circles.forEach(circle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = circle.color;
                    this.ctx.strokeStyle = circle.color.replace('0.1', '0.6');
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(circle.x, circle.y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.restore();

                    // Smart label positioning at circle edges
                    this.ctx.fillStyle = '#374151';
                    this.ctx.font = 'bold 16px Inter, sans-serif';
                    
                    let labelX, labelY, textAlign, textBaseline;
                    
                    if (circle.label === 'HRIS') {
                        // Left circle - label on left edge
                        labelX = circle.x - radius - 20;
                        labelY = circle.y;
                        textAlign = 'right';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Payroll') {
                        // Right circle - label on right edge  
                        labelX = circle.x + radius + 20;
                        labelY = circle.y;
                        textAlign = 'left';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Expense') {
                        // Bottom circle - label on bottom edge
                        labelX = circle.x;
                        labelY = circle.y + radius + 25;
                        textAlign = 'center';
                        textBaseline = 'top';
                    }
                    
                    this.ctx.textAlign = textAlign;
                    this.ctx.textBaseline = textBaseline;
                    
                    // Pixel-perfect label positioning
                    const pixelX = Math.round(labelX);
                    const pixelY = Math.round(labelY);
                    this.ctx.fillText(circle.label, pixelX, pixelY);
                });
            }

            drawCard(card) {
                // Skip hover-only cards unless we're hovering over their paired card or in edit mode
                if (card.isHoverOnly && !this.editABMode) {
                    const pairedCard = this.cards.find(c => c.id === card.pairedCardId);
                    const shouldShow = pairedCard && this.hoveredCard === pairedCard;
                    
                    // Also show if we're hovering over the B version
                    const bVersion = this.cards.find(c => c.pairedCardId === card.id && c.isVersion === 'B');
                    const hoveringB = bVersion && this.hoveredCard === bVersion;
                    
                    if (!shouldShow && !hoveringB && this.hoveredCard !== card) {
                        return;
                    }
                }
                
                const isSelected = this.selectedCards.includes(card);
                const isHovered = this.hoveredCard === card;
                const x = card.x - this.cardSize / 2;
                const y = card.y - this.cardSize / 2;

                this.ctx.save();
                
                // Apply transparency for A cards
                if (card.isVersion === 'A') {
                    this.ctx.globalAlpha = 0.5;
                }

                // Enhanced shadow effects
                if (isSelected) {
                    // Selected cards get a stronger shadow
                    this.ctx.shadowColor = 'rgba(59, 130, 246, 0.3)';
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowOffsetY = 4;
                } else if (isHovered) {
                    // Hovered cards get a subtle lift effect
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetY = 3;
                } else {
                    // Default shadow for unselected cards
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetY = 2;
                }

                // White background
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                this.ctx.fill();

                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;

                // Blue border if selected
                if (isSelected) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                    this.ctx.stroke();
                }

                // Draw logo if available, otherwise show initials
                const logo = this.loadedLogos.get(card.logo);
                if (logo && card.logo) {
                    // Draw logo centered in card
                    const logoSize = this.cardSize * 0.6;
                    const logoX = card.x - logoSize / 2;
                    const logoY = card.y - logoSize / 2;
                    
                    this.ctx.drawImage(logo, logoX, logoY, logoSize, logoSize);
                } else {
                    // Company initials - crisp text rendering
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.font = `bold ${Math.max(14, this.cardSize * 0.25)}px Inter, sans-serif`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const initials = card.company
                        .split(' ')
                        .filter(word => word.length > 0)
                        .slice(0, 2)
                        .map(word => word[0].toUpperCase())
                        .join('');
                    
                    // Ensure pixel-perfect text positioning
                    const textX = Math.round(card.x);
                    const textY = Math.round(card.y);
                    this.ctx.fillText(initials, textX, textY);
                }
                
                // Draw connection points
                this.drawConnectionPoints(card, isHovered);
                
                // Draw edit mode indicator
                if (this.editABMode && !card.isVersion) {
                    this.drawEditModeIndicator(card);
                }
                
                // Show company label on hover
                if (isHovered) {
                    this.drawHoverLabel(card);
                }
                
                this.ctx.restore();
            }

            drawHoverLabel(card) {
                this.ctx.save();
                
                // Label position below the card
                const labelY = card.y + this.cardSize / 2 + 15;
                
                // Measure text for background
                this.ctx.font = '14px Inter, sans-serif';
                const textWidth = this.ctx.measureText(card.company).width;
                const padding = 8;
                const bgWidth = textWidth + padding * 2;
                const bgHeight = 24;
                
                // Draw background with shadow
                this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                this.ctx.shadowBlur = 4;
                this.ctx.shadowOffsetY = 2;
                
                this.ctx.fillStyle = '#1e293b';
                this.ctx.beginPath();
                this.roundRect(
                    card.x - bgWidth / 2,
                    labelY - bgHeight / 2,
                    bgWidth,
                    bgHeight,
                    6
                );
                this.ctx.fill();
                
                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;
                
                // Draw text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(card.company, card.x, labelY);
                
                this.ctx.restore();
            }

            drawConnectionPoints(card, isHovered) {
                // Show version badge if card has a version
                if (card.isVersion) {
                    const badgeX = card.x + this.cardSize / 2 - 8;
                    const badgeY = card.y - this.cardSize / 2 + 8;
                    
                    this.ctx.save();
                    
                    // Badge background
                    this.ctx.fillStyle = card.isVersion === 'A' ? '#3b82f6' : '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(badgeX, badgeY, 10, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    // Badge border
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Badge letter
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 12px Inter, sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(card.isVersion, badgeX, badgeY);
                    
                    this.ctx.restore();
                }
            }

            drawEditModeIndicator(card) {
                this.ctx.save();
                
                // Draw dashed border around card
                this.ctx.strokeStyle = '#8b5cf6';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                const x = card.x - this.cardSize / 2 - 4;
                const y = card.y - this.cardSize / 2 - 4;
                const size = this.cardSize + 8;
                
                this.ctx.beginPath();
                this.roundRect(x, y, size, size, 12);
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            getConnectionPoint(card, type) {
                if (type === 'start' || card.isVersion === 'A') {
                    return {
                        x: card.x + this.cardSize / 2,
                        y: card.y
                    };
                } else {
                    return {
                        x: card.x - this.cardSize / 2,
                        y: card.y
                    };
                }
            }

            drawConnections() {
                this.connections.forEach(conn => {
                    const startCard = this.cards.find(c => c.id === conn.fromId);
                    const endCard = this.cards.find(c => c.id === conn.toId);
                    
                    // Skip connections from hover-only cards for now
                    if (startCard && startCard.isHoverOnly) {
                        return;
                    }
                    
                    if (startCard && endCard) {
                        this.drawConnection(startCard, endCard);
                    }
                });
            }

            drawHoverConnections() {
                // Draw connections for hover-only cards when appropriate
                this.connections.forEach(conn => {
                    const startCard = this.cards.find(c => c.id === conn.fromId);
                    const endCard = this.cards.find(c => c.id === conn.toId);
                    
                    if (startCard && startCard.isHoverOnly && endCard) {
                        // Check if we should show this connection
                        const shouldShow = this.editABMode || // Always show in edit mode
                                         this.hoveredCard === endCard || 
                                         this.hoveredCard === startCard ||
                                         (startCard.pairedCardId && this.hoveredCard?.id === startCard.pairedCardId);
                        
                        if (shouldShow) {
                            this.ctx.save();
                            if (!this.editABMode) {
                                this.ctx.globalAlpha = 0.5;
                            }
                            this.drawConnection(startCard, endCard);
                            this.ctx.restore();
                        }
                    }
                });
            }

            drawConnection(startCard, endCard) {
                const startPoint = this.getConnectionPoint(startCard, 'start');
                const endPoint = this.getConnectionPoint(endCard, 'end');
                
                this.ctx.save();
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                // Draw curved connector
                this.ctx.beginPath();
                this.ctx.moveTo(startPoint.x, startPoint.y);
                
                const midX = (startPoint.x + endPoint.x) / 2;
                const midY = (startPoint.y + endPoint.y) / 2;
                
                // Create a nice curve
                const distance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) + 
                    Math.pow(endPoint.y - startPoint.y, 2)
                );
                const curvature = Math.min(50, distance * 0.3);
                
                const controlX1 = startPoint.x + curvature;
                const controlY1 = startPoint.y;
                const controlX2 = endPoint.x - curvature;
                const controlY2 = endPoint.y;
                
                this.ctx.bezierCurveTo(
                    controlX1, controlY1,
                    controlX2, controlY2,
                    endPoint.x, endPoint.y
                );
                
                this.ctx.stroke();
                
                // Draw arrow at end
                this.ctx.setLineDash([]);
                const angle = Math.atan2(endPoint.y - controlY2, endPoint.x - controlX2);
                const arrowLength = 10;
                
                this.ctx.beginPath();
                this.ctx.moveTo(endPoint.x, endPoint.y);
                this.ctx.lineTo(
                    endPoint.x - arrowLength * Math.cos(angle - Math.PI / 6),
                    endPoint.y - arrowLength * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.moveTo(endPoint.x, endPoint.y);
                this.ctx.lineTo(
                    endPoint.x - arrowLength * Math.cos(angle + Math.PI / 6),
                    endPoint.y - arrowLength * Math.sin(angle + Math.PI / 6)
                );
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            roundRect(x, y, width, height, radius) {
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
            }

            initializeCleanCanvas() {
                // Preload all logos from assets
                this.preloadAllLogos();
            }

            preloadAllLogos() {
                // List of all available logos
                const logos = [
                    { file: 'adp.svg', name: 'ADP' },
                    { file: 'amp.svg', name: 'AMP' },
                    { file: 'bamboohr.svg', name: 'BambooHR' },
                    { file: 'brex.svg', name: 'Brex' },
                    { file: 'deel.svg', name: 'Deel' },
                    { file: 'factorial.svg', name: 'Factorial' },
                    { file: 'hibob.svg', name: 'HiBob' },
                    { file: 'justworks.svg', name: 'JustWorks' },
                    { file: 'lattice.svg', name: 'Lattice' },
                    { file: 'paychex.svg', name: 'Paychex' },
                    { file: 'paycom.svg', name: 'Paycom' },
                    { file: 'paylocity.svg', name: 'Paylocity' },
                    { file: 'personio.svg', name: 'Personio' },
                    { file: 'pleo.svg', name: 'Pleo' },
                    { file: 'ramp.svg', name: 'Ramp' },
                    { file: 'remote.svg', name: 'Remote' },
                    { file: 'revolut.svg', name: 'Revolut' },
                    { file: 'rippling.svg', name: 'Rippling' },
                    { file: 'spendesk.svg', name: 'Spendesk' },
                    { file: 'swile.svg', name: 'Swile' },
                    { file: 'teamtailor.svg', name: 'Teamtailor' },
                    { file: 'workable.svg', name: 'Workable' },
                    { file: 'workday.svg', name: 'Workday' }
                ];

                // Get canvas dimensions
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height * 0.4;

                // Create a grid layout for the cards
                const cardsPerRow = 8;
                const spacing = this.cardSize + 20;
                const startX = centerX - ((Math.min(cardsPerRow, logos.length) - 1) * spacing) / 2;
                const startY = centerY - 100;

                // Create cards for each logo
                logos.forEach((logo, index) => {
                    const row = Math.floor(index / cardsPerRow);
                    const col = index % cardsPerRow;
                    
                    const x = startX + col * spacing;
                    const y = startY + row * spacing;

                    this.createCard({
                        company: logo.name,
                        logo: logo.file,
                        x: x,
                        y: y
                    });
                });

                this.render();
            }

            async setupStorageBucket() {
                try {
                    console.log('ðŸ“ Setting up logos storage bucket...');
                    
                    // First, list all buckets to see what exists
                    const { data: buckets, error: listError } = await this.supabase.storage.listBuckets();
                    
                    if (listError) {
                        throw new Error(`Cannot list buckets: ${listError.message}`);
                    }
                    
                    console.log('ðŸ“‹ Existing buckets:', buckets.map(b => b.name));
                    
                    const logosBucket = buckets.find(bucket => bucket.name === 'logos');
                    
                    if (!logosBucket) {
                        if (SKIP_BUCKET_CREATION) {
                            console.log('âš ï¸ Logos bucket missing but skipping creation due to RLS. Please create manually.');
                            console.log('ðŸ“‹ MANUAL SETUP REQUIRED:');
                            console.log('1. Go to Supabase â†’ Storage');
                            console.log('2. Create bucket named "logos"');
                            console.log('3. Make it public');
                            console.log('4. Refresh this page');
                            throw new Error('Logos bucket does not exist. Please create it manually in Supabase.');
                        } else {
                            console.log('ðŸ“ Creating new logos bucket...');
                            
                            // Create bucket with proper settings and no RLS
                            const { data: createData, error: createError } = await this.supabase.storage.createBucket('logos', {
                                public: true,
                                allowedMimeTypes: ['image/svg+xml', 'image/png', 'image/jpeg'],
                                fileSizeLimit: 10485760 // 10MB
                            });

                            if (createError) {
                                throw new Error(`Bucket creation failed: ${createError.message}`);
                            }
                            
                            console.log('âœ… Logos bucket created:', createData);
                        }
                    } else {
                        console.log('âœ… Logos bucket already exists');
                    }
                    
                    // Test bucket accessibility
                    const { data: testList, error: testError } = await this.supabase.storage
                        .from('logos')
                        .list('', { limit: 1 });
                        
                    if (testError) {
                        throw new Error(`Bucket access test failed: ${testError.message}`);
                    }
                    
                    console.log('âœ… Bucket is accessible');
                    
                } catch (error) {
                    throw new Error(`Storage setup failed: ${error.message}`);
                }
            }

            async testStorageUpload() {
                try {
                    // Create a tiny test SVG
                    const testSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10"><circle cx="5" cy="5" r="3" fill="red"/></svg>';
                    const blob = new Blob([testSVG], { type: 'image/svg+xml' });
                    const testFileName = `test-${Date.now()}.svg`;
                    
                    // Try to upload
                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(testFileName, blob, {
                            cacheControl: '3600',
                            upsert: true,
                            contentType: 'image/svg+xml'
                        });

                    if (uploadError) {
                        throw new Error(`Test upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(testFileName);

                    console.log('ðŸ“¤ Test file uploaded:', urlData.publicUrl);

                    // Clean up test file
                    await this.supabase.storage
                        .from('logos')
                        .remove([testFileName]);
                        
                    console.log('ðŸ§¹ Test file cleaned up');

                } catch (error) {
                    throw new Error(`Storage test failed: ${error.message}`);
                }
            }

            async uploadLogoToStorage(file) {
                if (!this.supabase || !this.isConnected) {
                    throw new Error('Supabase not connected');
                }

                try {
                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const extension = file.name.split('.').pop() || (file.type.includes('svg') ? 'svg' : 'png');
                    const fileName = `logo-${timestamp}-${randomId}.${extension}`;

                    console.log('ðŸ“¤ UPLOADING:', fileName, 'Size:', file.size, 'Type:', file.type);

                    // Upload with proper options
                    const uploadOptions = {
                        cacheControl: '3600',
                        upsert: true // Allow overwrite to avoid conflicts
                    };

                    // Set correct content type
                    if (file.type.includes('svg')) {
                        uploadOptions.contentType = 'image/svg+xml';
                    } else if (file.type.includes('png')) {
                        uploadOptions.contentType = 'image/png';
                    }

                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, file, uploadOptions);

                    if (uploadError) {
                        console.error('ðŸ’¥ UPLOAD ERROR:', uploadError);
                        throw new Error(`Upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('ðŸŽ‰ UPLOAD SUCCESS:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('ðŸ’¥ LOGO UPLOAD COMPLETELY FAILED:', error);
                    throw error;
                }
            }

            async uploadSVGCodeToStorage(svgCode) {
                if (!this.supabase || !this.isConnected) {
                    throw new Error('Supabase not connected');
                }

                try {
                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const fileName = `svg-${timestamp}-${randomId}.svg`;

                    console.log('ðŸ“¤ UPLOADING SVG CODE:', fileName, 'Length:', svgCode.length);

                    // Create blob from SVG code with proper MIME type
                    const blob = new Blob([svgCode], { type: 'image/svg+xml' });

                    // Upload to Supabase Storage
                    const { data: uploadData, error: uploadError } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, blob, {
                            cacheControl: '3600',
                            upsert: true,
                            contentType: 'image/svg+xml'
                        });

                    if (uploadError) {
                        console.error('ðŸ’¥ SVG UPLOAD ERROR:', uploadError);
                        throw new Error(`SVG upload failed: ${uploadError.message}`);
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('ðŸŽ‰ SVG UPLOAD SUCCESS:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('ðŸ’¥ SVG UPLOAD COMPLETELY FAILED:', error);
                    throw error;
                }
            }



            exportCanvas() {
                const link = document.createElement('a');
                link.download = 'business-cards.png';
                link.href = this.canvas.toDataURL();
                link.click();
                // No notification needed for export
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => notification.remove(), 3000);
            }

            updateSaveButton() {
                const saveBtn = document.getElementById('saveEditFab');
                if (this.hasUnsavedChanges) {
                    saveBtn.classList.add('pulse');
                } else {
                    saveBtn.classList.remove('pulse');
                }
            }

            storeEditState() {
                // Deep clone the current state
                this.editStartState = {
                    cards: JSON.parse(JSON.stringify(this.cards)),
                    connections: JSON.parse(JSON.stringify(this.connections))
                };
            }

            restoreEditState() {
                if (this.editStartState) {
                    this.cards = this.editStartState.cards;
                    this.connections = this.editStartState.connections;
                    this.editStartState = null;
                    this.render();
                }
            }
        }

        // Global functions for onclick handlers
        let app;
        let uploadedLogoData = null; // Store uploaded logo data

        function openAddCardModal() {
            document.getElementById('addCardModal').classList.add('show');
            setupFileUpload();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            if (modalId === 'addCardModal') {
                resetFileUpload();
            }
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const fileInput = document.getElementById('logoFileInput');
            const uploadContent = uploadArea.querySelector('.upload-content');
            
            // Click to upload
            uploadArea.addEventListener('click', () => {
                if (!uploadArea.querySelector('.logo-preview').style.display || 
                    uploadArea.querySelector('.logo-preview').style.display === 'none') {
                    fileInput.click();
                }
            });
            
            // File input change
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Paste SVG code
            uploadArea.addEventListener('paste', handlePaste);
            uploadArea.setAttribute('tabindex', '0'); // Make it focusable for paste
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            
            const files = Array.from(e.dataTransfer.files);
            const text = e.dataTransfer.getData('text');
            
            if (files.length > 0) {
                const file = files.find(f => f.type.includes('svg') || f.type.includes('png'));
                if (file) {
                    await processFile(file);
                }
            } else if (text && (text.includes('<svg') || text.startsWith('data:image'))) {
                await processSVGCode(text);
            }
        }

        async function handlePaste(e) {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            if (text && text.includes('<svg')) {
                await processSVGCode(text);
            }
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                await processFile(file);
            }
        }

        async function processFile(file) {
            if (!file.type.includes('svg') && !file.type.includes('png')) {
                app.showNotification('Please upload SVG or PNG files only', 'error');
                return;
            }
            
            const uploadArea = document.getElementById('logoUploadArea');
            
            try {
                // For local mode, just use data URL
                const reader = new FileReader();
                reader.onload = (e) => {
                    showLogoPreview(e.target.result);
                    uploadedLogoData = e.target.result;
                };
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('Error processing file:', error);
                app.showNotification('Error processing logo file', 'error');
            }
        }

        async function processSVGCode(svgCode) {
            try {
                // Clean and validate SVG
                const cleanSVG = svgCode.trim();
                if (!cleanSVG.includes('<svg')) {
                    throw new Error('Invalid SVG');
                }
                
                // For local mode, just use data URL
                const dataUrl = 'data:image/svg+xml;base64,' + btoa(cleanSVG);
                showLogoPreview(dataUrl);
                uploadedLogoData = dataUrl;
            } catch (error) {
                app.showNotification('Invalid SVG code', 'error');
            }
        }

        function showLogoPreview(dataUrl) {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const previewImg = document.getElementById('logoPreviewImg');
            
            uploadContent.style.display = 'none';
            preview.style.display = 'block';
            previewImg.src = dataUrl;
        }

        function removeLogo() {
            resetFileUpload();
            uploadedLogoData = null;
            // Also reset the dropdown
            document.getElementById('logoSelect').value = '';
        }

        function handleLogoSelect() {
            const select = document.getElementById('logoSelect');
            const selectedLogo = select.value;
            
            if (selectedLogo) {
                // Show preview using local asset
                showLogoPreview(`assets/logos/${selectedLogo}`);
                uploadedLogoData = selectedLogo; // Just store the filename
            } else {
                removeLogo();
            }
        }

        function resetFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const fileInput = document.getElementById('logoFileInput');
            const logoSelect = document.getElementById('logoSelect');
            
            uploadContent.style.display = 'block';
            preview.style.display = 'none';
            fileInput.value = '';
            logoSelect.value = '';
            uploadedLogoData = null;
        }

        function addBusinessCard() {
            const companyName = document.getElementById('companyName').value.trim();

            if (!companyName) {
                app.showNotification('Please enter a company name', 'error');
                return;
            }

            if (!app.clickPosition.x && !app.clickPosition.y) {
                app.clickPosition = { x: 400, y: 300 }; // Default position
            }

            app.createCard({
                company: companyName,
                logo: uploadedLogoData, // Use uploaded logo data
                x: app.clickPosition.x,
                y: app.clickPosition.y
            });

            app.render();
            closeModal('addCardModal');
            // No notification needed for adding cards
            
            // Clear form
            document.getElementById('companyName').value = '';
            resetFileUpload();
        }



        function exportCanvas() {
            app.exportCanvas();
        }

        function toggleControlsModal() {
            document.getElementById('controlsModal').classList.add('show');
        }

        function toggleDuplicateMode() {
            app.duplicateMode = !app.duplicateMode;
            const fab = document.getElementById('duplicateFab');
            
            // Disable edit mode if active
            if (app.editABMode) {
                toggleEditABMode();
            }
            
            if (app.duplicateMode) {
                fab.classList.add('active');
                app.canvas.style.cursor = 'copy';
                app.selectedCards = [];
                app.cardToDuplicate = null;
                app.showNotification('A/B Mode: 1) Click a card 2) Place point A (hover) 3) Place point B', 'info');
            } else {
                fab.classList.remove('active');
                app.canvas.style.cursor = 'default';
                app.cardToDuplicate = null;
                app.showNotification('A/B Mode disabled', 'info');
            }
            app.render();
        }

        function toggleEditABMode() {
            app.editABMode = !app.editABMode;
            const fab = document.getElementById('editABFab');
            const saveBtn = document.getElementById('saveEditFab');
            
            // Disable duplicate mode if active
            if (app.duplicateMode) {
                toggleDuplicateMode();
            }
            
            if (app.editABMode) {
                // Entering edit mode
                fab.classList.add('active');
                saveBtn.style.display = 'block';
                app.canvas.style.cursor = 'crosshair';
                app.selectedCards = [];
                app.editingCard = null;
                app.draggingPoint = null;
                app.hasUnsavedChanges = false;
                app.storeEditState();
                app.updateSaveButton();
                app.showNotification('Edit A/B Mode: Click cards to add A/B points, or drag existing points', 'info');
            } else {
                // Exiting edit mode
                if (app.hasUnsavedChanges) {
                    if (confirm('You have unsaved changes. Do you want to save them?')) {
                        saveEditChanges();
                    } else {
                        app.restoreEditState();
                    }
                }
                fab.classList.remove('active');
                saveBtn.style.display = 'none';
                app.canvas.style.cursor = 'default';
                app.editingCard = null;
                app.draggingPoint = null;
                app.hasUnsavedChanges = false;
                app.showNotification('Edit A/B Mode disabled', 'info');
            }
            app.render();
        }

        function saveEditChanges() {
            if (!app.editABMode) return;
            
            app.saveToSupabase();
            app.hasUnsavedChanges = false;
            app.editStartState = null;
            app.updateSaveButton();
            app.showNotification('Changes saved successfully!', 'success');
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            app = new BusinessCardCanvas();
            
            // Style the controls FAB
            const controlsFab = document.getElementById('controlsFab');
            controlsFab.className = 'floating-button controls';
            
            // Setup control sliders and checkbox
            const radiusSlider = document.getElementById('radiusSlider');
            const distanceSlider = document.getElementById('distanceSlider');
            const cardSizeSlider = document.getElementById('cardSizeSlider');
            const radiusValue = document.getElementById('radiusValue');
            const distanceValue = document.getElementById('distanceValue');
            const cardSizeValue = document.getElementById('cardSizeValue');
            const showCirclesCheckbox = document.getElementById('showCirclesCheckbox');
            
            // Update UI with loaded values
            app.updateControlsUI();
            
            radiusSlider.addEventListener('input', (e) => {
                app.circleRadius = parseInt(e.target.value);
                radiusValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            distanceSlider.addEventListener('input', (e) => {
                app.centerDistance = parseInt(e.target.value);
                distanceValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            cardSizeSlider.addEventListener('input', (e) => {
                app.cardSize = parseInt(e.target.value);
                cardSizeValue.textContent = e.target.value;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            showCirclesCheckbox.addEventListener('change', (e) => {
                app.showCircles = e.target.checked;
                app.render();
                app.hasChanges = true; // Mark for autosave
            });
            
            console.log('âœ… Business Card Canvas ready with real-time collaboration');
            console.log('ðŸŒ Multi-device collaboration: Supabase-powered');
            console.log('ðŸ’¾ Auto-save: Instant across all devices');
            
            // Setup instructions
            if (!app.isConnected) {
                console.log('');
                console.log('ðŸš€ SETUP SUPABASE FOR REAL COLLABORATION:');
                console.log('1. Go to https://supabase.com and create a project');
                console.log('2. Run this SQL in the SQL Editor:');
                console.log(`
CREATE TABLE canvas_data (
  id text PRIMARY KEY DEFAULT 'shared-canvas',
  cards jsonb DEFAULT '[]'::jsonb,
  settings jsonb DEFAULT '{}'::jsonb,
  updated_at timestamp with time zone DEFAULT now()
);
ALTER PUBLICATION supabase_realtime ADD TABLE canvas_data;
INSERT INTO canvas_data (id) VALUES ('shared-canvas');`);
                console.log('3. Update supabaseConfig with your project URL and anon key');
                console.log('4. Refresh and enjoy real multi-device collaboration! ðŸŽ‰');
                console.log('');
            }
        });
    </script>
</body>
</html> 