<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Business Card Canvas</title>
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --color-background: #ffffff;
            --color-surface: #f8fafc;
            --color-border: #e2e8f0;
            --color-text-primary: #1e293b;
            --color-primary: #3b82f6;
            --space-md: 1rem;
            --space-lg: 1.5rem;
            --radius-lg: 12px;
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--color-background);
            color: var(--color-text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: var(--color-background);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: var(--color-background);
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: var(--color-background);
            cursor: default;
        }

        .floating-controls {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            z-index: 1000;
        }

        .floating-button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: var(--color-primary);
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.2s;
        }

        .floating-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px -4px rgba(0, 0, 0, 0.2);
        }

        .floating-button.success { background: #10b981; }
        .floating-button.active { background: #8b5cf6; }
        .floating-button.inactive { background: #64748b; }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .modal-content {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-md);
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-lg);
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--color-text-primary);
        }

        .form-group {
            margin-bottom: var(--space-md);
        }

        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--color-primary);
            color: white;
        }

        .btn-secondary {
            background: var(--color-surface);
            color: var(--color-text-primary);
            border: 1px solid var(--color-border);
        }

        .modal-footer {
            display: flex;
            gap: var(--space-md);
            justify-content: flex-end;
            margin-top: var(--space-lg);
        }

        .notification {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            box-shadow: var(--shadow-md);
            z-index: 3000;
            max-width: 300px;
        }

        .notification.success { border-left: 4px solid #10b981; }
        .notification.error { border-left: 4px solid #ef4444; }
        .notification.info { border-left: 4px solid var(--color-primary); }

        .floating-button.controls { background: #8b5cf6; }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            left: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-md);
            z-index: 1000;
            font-size: 14px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 2s infinite;
        }

        .status-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .file-upload-area {
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--color-surface);
        }

        .file-upload-area:hover {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.05);
        }

        .file-upload-area.drag-over {
            border-color: var(--color-primary);
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.02);
        }

        .upload-content i {
            font-size: 24px;
            color: var(--color-primary);
            margin-bottom: 8px;
        }

        .upload-content p {
            margin: 4px 0;
            font-size: 14px;
        }

        .upload-hint {
            color: #64748b;
            font-size: 12px !important;
        }

        .logo-preview {
            position: relative;
            max-width: 120px;
            margin: 0 auto;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 8px;
            background: white;
        }

        .logo-preview img {
            width: 100%;
            height: auto;
            max-height: 60px;
            object-fit: contain;
        }

        .remove-logo {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
        }

        .autosave-status {
            position: fixed;
            top: var(--space-lg);
            right: var(--space-lg);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 8px 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 1000;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
        }

        .control-group {
            margin-bottom: var(--space-md);
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--color-text-primary);
        }

        .control-label input[type="checkbox"] {
            margin-right: 8px;
        }

        .control-slider {
            width: 100%;
            height: 4px;
            background: var(--color-border);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .control-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--color-primary);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>

        <!-- Circle Controls Modal -->
        <div class="modal" id="controlsModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title">Circle Controls</h2>
                    <button class="modal-close" onclick="closeModal('controlsModal')">√ó</button>
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Radius: <span id="radiusValue">200</span>px</label>
                    <input type="range" id="radiusSlider" min="50" max="500" value="200" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Circle Distance: <span id="distanceValue">200</span>px</label>
                    <input type="range" id="distanceSlider" min="50" max="300" value="200" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">Card Size: <span id="cardSizeValue">80</span>px</label>
                    <input type="range" id="cardSizeSlider" min="40" max="120" value="80" class="control-slider">
                </div>
                
                <div class="control-group">
                    <label class="control-label">
                        <input type="checkbox" id="showCirclesCheckbox" checked> Show Circles
                    </label>
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-primary" onclick="closeModal('controlsModal')">Done</button>
                </div>
            </div>
        </div>

        <!-- Auto-save Status -->
        <div class="autosave-status">
            <div class="status-indicator" id="statusIndicator"></div>
            <span id="statusText">Auto-save Active</span>
        </div>

        <div class="floating-controls">
            <button class="floating-button" onclick="openAddCardModal()" title="Add Card">
                <i class="fas fa-plus"></i>
            </button>
            <button class="floating-button" onclick="toggleControlsModal()" title="Circle Controls" id="controlsFab">
                <i class="fas fa-sliders-h"></i>
            </button>

            <button class="floating-button success" onclick="exportCanvas()" title="Export">
                <i class="fas fa-download"></i>
            </button>
        </div>
    </div>

    <!-- Add Card Modal -->
    <div class="modal" id="addCardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Add Business Card</h2>
                <button class="modal-close" onclick="closeModal('addCardModal')">√ó</button>
            </div>
            
            <div class="form-group">
                <label class="form-label">Company Name</label>
                <input type="text" id="companyName" class="form-input" placeholder="Enter company name">
            </div>
            
            <div class="form-group">
                <label class="form-label">Logo Upload</label>
                <div class="file-upload-area" id="logoUploadArea">
                    <div class="upload-content">
                        <i class="fas fa-cloud-upload-alt"></i>
                        <p>Drag & drop SVG/PNG files or SVG code here</p>
                        <p class="upload-hint">or click to browse</p>
                    </div>
                    <input type="file" id="logoFileInput" accept=".svg,.png,image/svg+xml,image/png" style="display: none;">
                    <div class="logo-preview" id="logoPreview" style="display: none;">
                        <img id="logoPreviewImg" alt="Logo preview">
                        <button type="button" class="remove-logo" onclick="removeLogo()">&times;</button>
                    </div>
                </div>
            </div>
            

            
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addCardModal')">Cancel</button>
                <button class="btn btn-primary" onclick="addBusinessCard()">Add Card</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script>
        // REAL Supabase setup - configured with your project
        const supabaseConfig = {
            url: 'https://djoboiwyethvkswrhlsp.supabase.co',
            key: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRqb2JvaXd5ZXRodmtzd3JobHNwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk0NjYzMDYsImV4cCI6MjA2NTA0MjMwNn0.69O6lLpFYkh7Y9fIMCeAq81b-TVC_uN_XRn34SVWCYI'
        };

        // Global Supabase client
        let supabaseClient = null;

        // Business Card Canvas with REAL Supabase
        class BusinessCardCanvas {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cards = [];
                this.selectedCards = [];
                this.clickPosition = { x: 0, y: 0 };
                this.showCircles = true;
                this.isDragging = false;
                this.dragStartPos = null;
                this.hoveredCard = null;
                this.loadedLogos = new Map();
                
                this.circleRadius = 200;
                this.centerDistance = 200;
                this.cardSize = 80;
                
                // Real collaboration setup
                this.supabase = null;
                this.subscription = null;
                this.isConnected = false;
                this.isUpdating = false;
                this.dragSaveTimeout = null;
                
                this.init();
            }

            init() {
                // Clear any old localStorage data to start fresh
                localStorage.removeItem('venn-canvas-local');
                console.log('üßπ Cleared localStorage - starting with clean canvas');
                
                this.initSupabase();
                this.resizeCanvas();
                this.setupEventListeners();
                window.addEventListener('resize', () => this.resizeCanvas());
                this.render();
            }

            async initSupabase() {
                try {
                    // Test Supabase connection
                    console.log('üîÑ Testing Supabase connection...');
                    supabaseClient = supabase.createClient(supabaseConfig.url, supabaseConfig.key);
                    
                    // Test the connection with a simple query
                    const { data, error } = await supabaseClient
                        .from('canvas_data')
                        .select('id')
                        .limit(1);
                    
                    if (error) {
                        console.error('‚ùå Supabase connection test failed:', error);
                        throw error;
                    }
                    
                    console.log('‚úÖ Supabase connection successful!');
                    this.supabase = supabaseClient;
                    this.isConnected = true;
                    
                    // Load initial data
                    await this.loadFromSupabase();
                    
                    // Set up real-time collaboration
                    this.setupRealTimeSubscription();
                    this.updateStatus('connected', 'Multi-Device Collaboration Active üåê');
                    
                } catch (error) {
                    console.error('‚ùå Supabase setup failed:', error.message);
                    this.updateStatus('disconnected', 'Local Mode - No Collaboration');
                    
                    // Fallback to localStorage only
                    this.loadFromStorage();
                    if (this.cards.length === 0) {
                        this.initializeCleanCanvas();
                    }
                }
            }

            updateStatus(status, text) {
                const statusText = document.getElementById('statusText');
                const statusIndicator = document.getElementById('statusIndicator');
                
                statusText.textContent = text;
                this.isConnected = status === 'connected';
                
                if (status === 'connected') {
                    statusText.style.color = '#10b981';
                    statusIndicator.className = 'status-indicator';
                    statusIndicator.style.background = '#10b981';
                } else {
                    statusText.style.color = '#ef4444';
                    statusIndicator.className = 'status-indicator disconnected';
                    statusIndicator.style.background = '#ef4444';
                }
            }

            async loadFromSupabase() {
                if (!this.supabase) return;

                try {
                    console.log('üì• Loading data from Supabase...');
                    
                    const { data, error } = await this.supabase
                        .from('canvas_data')
                        .select('*')
                        .eq('id', 'shared-canvas')
                        .single();

                    if (error) {
                        if (error.code === 'PGRST116') {
                            // No data found, create initial record
                            console.log('üìù No data found, creating initial record...');
                            await this.createInitialRecord();
                            return;
                        }
                        throw error;
                    }

                    if (data) {
                        // Force clear any old pre-populated data
                        console.log('üßπ Clearing old Supabase data and starting fresh...');
                        await this.clearSupabaseData();
                        this.cards = [];
                        console.log('‚úÖ Supabase data cleared - clean canvas ready');
                    }

                    // Always start with clean canvas
                    this.initializeCleanCanvas();
                } catch (error) {
                    console.error('‚ùå Error loading from Supabase:', error.message);
                    this.initializeCleanCanvas();
                }
            }

            async clearSupabaseData() {
                try {
                    const { error } = await this.supabase
                        .from('canvas_data')
                        .update({
                            cards: [],
                            settings: {
                                circleRadius: 200,
                                centerDistance: 200,
                                cardSize: 80,
                                showCircles: true
                            },
                            updated_at: new Date().toISOString()
                        })
                        .eq('id', 'shared-canvas');

                    if (error) throw error;
                    console.log('‚úÖ Cleared Supabase data successfully');
                } catch (error) {
                    console.error('‚ùå Failed to clear Supabase data:', error.message);
                }
            }

            async createInitialRecord() {
                try {
                    const initialData = {
                        id: 'shared-canvas',
                        cards: [],
                        settings: {
                            circleRadius: 200,
                            centerDistance: 200,
                            cardSize: 80,
                            showCircles: true
                        },
                        updated_at: new Date().toISOString()
                    };

                    // First try to clear any existing data
                    await this.supabase
                        .from('canvas_data')
                        .delete()
                        .eq('id', 'shared-canvas');

                    // Then insert fresh empty data
                    const { error } = await this.supabase
                        .from('canvas_data')
                        .insert(initialData);

                    if (error) throw error;
                    
                    console.log('‚úÖ Created fresh empty Supabase record');
                    this.initializeCleanCanvas();
                } catch (error) {
                    console.error('‚ùå Failed to create initial record:', error.message);
                    this.initializeCleanCanvas();
                }
            }

            setupRealTimeSubscription() {
                if (!this.supabase) return;

                console.log('üîî Setting up real-time subscription...');
                
                // Subscribe to real-time changes
                this.subscription = this.supabase
                    .channel('canvas-realtime')
                    .on('postgres_changes', 
                        { 
                            event: 'UPDATE', 
                            schema: 'public', 
                            table: 'canvas_data',
                            filter: 'id=eq.shared-canvas'
                        },
                        (payload) => {
                            if (!this.isUpdating) {
                                console.log('üì° Received real-time update from another device!');
                                this.handleRealtimeUpdate(payload.new);
                            }
                        }
                    )
                    .subscribe((status) => {
                        console.log('üì° Real-time subscription status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Real-time collaboration is ACTIVE!');
                        }
                    });
            }

            handleRealtimeUpdate(data) {
                console.log('üì° INSTANT UPDATE received from another device!', {
                    cards: data.cards?.length || 0,
                    isDragging: this.isDragging
                });
                
                // Update immediately for instant sync
                this.cards = data.cards || [];
                if (data.settings) {
                    this.circleRadius = data.settings.circleRadius || 200;
                    this.centerDistance = data.settings.centerDistance || 200;
                    this.cardSize = data.settings.cardSize || 80;
                    this.showCircles = data.settings.showCircles !== false;
                    this.updateControlsUI();
                }
                this.render();
            }

            async saveToSupabase() {
                if (!this.supabase || !this.isConnected) {
                    console.log('üíæ No Supabase connection - saving locally only');
                    this.saveToStorage();
                    return;
                }

                this.isUpdating = true; // Prevent infinite loops
                
                try {
                    const saveData = {
                        id: 'shared-canvas',
                        cards: this.cards,
                        settings: {
                            circleRadius: this.circleRadius,
                            centerDistance: this.centerDistance,
                            cardSize: this.cardSize,
                            showCircles: this.showCircles
                        },
                        updated_at: new Date().toISOString()
                    };

                    console.log('üíæ Saving to Supabase...', { cards: this.cards.length });

                    const { error } = await this.supabase
                        .from('canvas_data')
                        .upsert(saveData, { onConflict: 'id' });

                    if (error) {
                        console.error('‚ùå Supabase save error:', error);
                        throw error;
                    }

                    console.log('‚úÖ Successfully saved to Supabase - all devices will sync!');
                    // No need for constant status updates - just keep it simple

                } catch (error) {
                    console.error('‚ùå Save to Supabase failed:', error.message);
                    this.updateStatus('disconnected', 'Sync Failed - Local Only');
                    this.saveToStorage();
                } finally {
                    this.isUpdating = false;
                }
            }

            // Fallback localStorage methods (for when Firebase isn't configured)
            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('venn-canvas-local');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.cards = data.cards || [];
                        if (data.settings) {
                            this.circleRadius = data.settings.circleRadius || 200;
                            this.centerDistance = data.settings.centerDistance || 200;
                            this.cardSize = data.settings.cardSize || 80;
                            this.showCircles = data.settings.showCircles !== false;
                        }
                    }
                } catch (error) {
                    console.log('Error loading local data:', error);
                }
            }

            saveToStorage() {
                const data = {
                    cards: this.cards,
                    settings: {
                        circleRadius: this.circleRadius,
                        centerDistance: this.centerDistance,
                        cardSize: this.cardSize,
                        showCircles: this.showCircles
                    }
                };
                localStorage.setItem('venn-canvas-local', JSON.stringify(data));
            }

            updateControlsUI() {
                document.getElementById('radiusSlider').value = this.circleRadius;
                document.getElementById('radiusValue').textContent = this.circleRadius;
                document.getElementById('distanceSlider').value = this.centerDistance;
                document.getElementById('distanceValue').textContent = this.centerDistance;
                document.getElementById('cardSizeSlider').value = this.cardSize;
                document.getElementById('cardSizeValue').textContent = this.cardSize;
                document.getElementById('showCirclesCheckbox').checked = this.showCircles;
            }

            resizeCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                // Set actual canvas size for crisp vector rendering
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                
                // Scale canvas back down using CSS
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                
                // Scale the drawing context so everything draws at correct size
                this.ctx.scale(dpr, dpr);
                
                // Enable crisp text and shape rendering
                this.ctx.textRenderingOptimization = 'optimizeQuality';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                this.render();
            }

            setupEventListeners() {
                // Mouse move for hover effects and dragging
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    if (this.isDragging && this.selectedCards.length > 0) {
                        // Dragging - show closed hand cursor
                        this.canvas.style.cursor = 'grabbing';
                        
                        if (this.dragStartPos) {
                            const deltaX = mousePos.x - this.dragStartPos.x;
                            const deltaY = mousePos.y - this.dragStartPos.y;
                            
                            // Move selected cards
                            this.selectedCards.forEach(card => {
                                card.x += deltaX;
                                card.y += deltaY;
                            });
                            
                            this.dragStartPos = mousePos;
                            this.render();
                            
                            // INSTANT sync - no debouncing, save immediately
                            this.saveToSupabase();
                        }
                    } else {
                        // Check hover state
                        const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                        if (hoveredCard !== this.hoveredCard) {
                            this.hoveredCard = hoveredCard;
                            
                            if (hoveredCard) {
                                // Show open hand cursor when hovering over card
                                this.canvas.style.cursor = 'grab';
                            } else {
                                // Default cursor when not over card
                                this.canvas.style.cursor = 'default';
                            }
                        }
                    }
                });

                // Mouse down to start selection/dragging
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.clickPosition = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const clickedCard = this.getCardAt(this.clickPosition.x, this.clickPosition.y);
                    if (clickedCard) {
                        // Start dragging
                        this.isDragging = true;
                        this.dragStartPos = this.clickPosition;
                        this.canvas.style.cursor = 'grabbing';
                        
                        // Select card if not already selected
                        if (!this.selectedCards.includes(clickedCard)) {
                            if (!e.shiftKey) {
                                this.selectedCards = [clickedCard];
                            } else {
                                this.selectedCards.push(clickedCard);
                            }
                        }
                    } else {
                        // Clear selection if clicking empty space
                        this.selectedCards = [];
                        this.isDragging = false;
                    }
                    this.render();
                });

                // Mouse up to end dragging
                this.canvas.addEventListener('mouseup', (e) => {
                    this.isDragging = false;
                    this.dragStartPos = null;
                    
                    // Reset cursor based on current hover state
                    const rect = this.canvas.getBoundingClientRect();
                    const mousePos = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const hoveredCard = this.getCardAt(mousePos.x, mousePos.y);
                    this.canvas.style.cursor = hoveredCard ? 'grab' : 'default';
                });

                // Mouse leave to reset cursor
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDragging = false;
                    this.dragStartPos = null;
                    this.hoveredCard = null;
                    this.canvas.style.cursor = 'default';
                });
            }

            getCardAt(x, y) {
                return this.cards.find(card => {
                    const dist = Math.sqrt(
                        Math.pow(x - card.x, 2) + Math.pow(y - card.y, 2)
                    );
                    return dist <= this.cardSize / 2;
                });
            }

            toggleCardSelection(card) {
                const index = this.selectedCards.indexOf(card);
                if (index > -1) {
                    this.selectedCards.splice(index, 1);
                } else {
                    this.selectedCards.push(card);
                }
            }

            createCard(data) {
                const card = {
                    id: Date.now() + Math.random(),
                    company: data.company,
                    logo: data.logo || '',
                    x: data.x,
                    y: data.y
                };
                this.cards.push(card);
                
                // Pre-load logo if provided
                if (card.logo) {
                    this.loadLogo(card.logo);
                }
                
                // Save to Supabase for real-time collaboration
                this.saveToSupabase();
                
                return card;
            }

            async loadLogo(logoUrl) {
                if (this.loadedLogos.has(logoUrl)) return this.loadedLogos.get(logoUrl);

                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        this.loadedLogos.set(logoUrl, img);
                        // Only re-render if not currently dragging to prevent flashing
                        if (!this.isDragging) {
                            this.render();
                        }
                        resolve(img);
                    };
                    
                    img.onerror = () => {
                        console.log('Failed to load logo:', logoUrl);
                        resolve(null);
                    };
                    
                    img.src = logoUrl;
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // White background
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw circles
                if (this.showCircles) {
                    this.drawCircles();
                }
                
                // Draw cards
                this.cards.forEach(card => this.drawCard(card));
            }

            drawCircles() {
                const rect = this.canvas.getBoundingClientRect();
                const centerX = rect.width / 2;
                // Move circles higher - use 40% from top instead of center
                const centerY = rect.height * 0.4;
                const radius = this.circleRadius;
                const offset = this.centerDistance;

                const circles = [
                    { x: centerX - offset, y: centerY - offset/2, label: 'HRIS', color: 'rgba(59, 130, 246, 0.1)' },
                    { x: centerX + offset, y: centerY - offset/2, label: 'Payroll', color: 'rgba(16, 185, 129, 0.1)' },
                    { x: centerX, y: centerY + offset, label: 'Expense', color: 'rgba(239, 68, 68, 0.1)' }
                ];

                circles.forEach(circle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = 0.3;
                    this.ctx.fillStyle = circle.color;
                    this.ctx.strokeStyle = circle.color.replace('0.1', '0.6');
                    this.ctx.lineWidth = 2;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(circle.x, circle.y, radius, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    this.ctx.restore();

                    // Smart label positioning at circle edges
                    this.ctx.fillStyle = '#374151';
                    this.ctx.font = 'bold 16px Inter, sans-serif';
                    
                    let labelX, labelY, textAlign, textBaseline;
                    
                    if (circle.label === 'HRIS') {
                        // Left circle - label on left edge
                        labelX = circle.x - radius - 20;
                        labelY = circle.y;
                        textAlign = 'right';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Payroll') {
                        // Right circle - label on right edge  
                        labelX = circle.x + radius + 20;
                        labelY = circle.y;
                        textAlign = 'left';
                        textBaseline = 'middle';
                    } else if (circle.label === 'Expense') {
                        // Bottom circle - label on bottom edge
                        labelX = circle.x;
                        labelY = circle.y + radius + 25;
                        textAlign = 'center';
                        textBaseline = 'top';
                    }
                    
                    this.ctx.textAlign = textAlign;
                    this.ctx.textBaseline = textBaseline;
                    
                    // Pixel-perfect label positioning
                    const pixelX = Math.round(labelX);
                    const pixelY = Math.round(labelY);
                    this.ctx.fillText(circle.label, pixelX, pixelY);
                });
            }

            drawCard(card) {
                const isSelected = this.selectedCards.includes(card);
                const isHovered = this.hoveredCard === card;
                const x = card.x - this.cardSize / 2;
                const y = card.y - this.cardSize / 2;

                this.ctx.save();

                // Enhanced shadow effects
                if (isSelected) {
                    // Selected cards get a stronger shadow
                    this.ctx.shadowColor = 'rgba(59, 130, 246, 0.3)';
                    this.ctx.shadowBlur = 12;
                    this.ctx.shadowOffsetY = 4;
                } else if (isHovered) {
                    // Hovered cards get a subtle lift effect
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
                    this.ctx.shadowBlur = 10;
                    this.ctx.shadowOffsetY = 3;
                } else {
                    // Default shadow for unselected cards
                    this.ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
                    this.ctx.shadowBlur = 8;
                    this.ctx.shadowOffsetY = 2;
                }

                // White background
                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                this.ctx.fill();

                // Reset shadow
                this.ctx.shadowColor = 'transparent';
                this.ctx.shadowBlur = 0;
                this.ctx.shadowOffsetY = 0;

                // Blue border if selected
                if (isSelected) {
                    this.ctx.strokeStyle = '#3b82f6';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.roundRect(x, y, this.cardSize, this.cardSize, 12);
                    this.ctx.stroke();
                }

                // Draw logo if available, otherwise show initials
                const logo = this.loadedLogos.get(card.logo);
                if (logo && card.logo) {
                    // Draw logo centered in card
                    const logoSize = this.cardSize * 0.6;
                    const logoX = card.x - logoSize / 2;
                    const logoY = card.y - logoSize / 2;
                    
                    this.ctx.drawImage(logo, logoX, logoY, logoSize, logoSize);
                } else {
                    // Company initials - crisp text rendering
                    this.ctx.fillStyle = '#1e293b';
                    this.ctx.font = `bold ${Math.max(14, this.cardSize * 0.25)}px Inter, sans-serif`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const initials = card.company
                        .split(' ')
                        .filter(word => word.length > 0)
                        .slice(0, 2)
                        .map(word => word[0].toUpperCase())
                        .join('');
                    
                    // Ensure pixel-perfect text positioning
                    const textX = Math.round(card.x);
                    const textY = Math.round(card.y);
                    this.ctx.fillText(initials, textX, textY);
                }
                
                this.ctx.restore();
            }

            roundRect(x, y, width, height, radius) {
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
            }

            initializeCleanCanvas() {
                // Start with an empty canvas - no default cards
                this.render();
            }

            async ensureLogosStorage() {
                try {
                    // Check if logos bucket exists
                    const { data: buckets, error: listError } = await this.supabase.storage.listBuckets();
                    
                    if (listError) {
                        console.error('‚ùå Could not list buckets:', listError);
                        return;
                    }

                    const logosBucket = buckets.find(bucket => bucket.name === 'logos');
                    
                    if (!logosBucket) {
                        console.log('üìÅ Creating logos storage bucket...');
                        
                        // Create the bucket
                        const { data, error } = await this.supabase.storage.createBucket('logos', {
                            public: true,
                            allowedMimeTypes: ['image/svg+xml', 'image/png'],
                            fileSizeLimit: 10485760 // 10MB
                        });

                        if (error) {
                            console.error('‚ùå Failed to create logos bucket:', error);
                            return;
                        }
                        
                        console.log('‚úÖ Logos storage bucket created successfully');
                    }
                } catch (error) {
                    console.error('‚ùå Error setting up storage:', error);
                }
            }

            async uploadLogoToStorage(file) {
                if (!this.supabase || !this.isConnected) {
                    console.log('üìÅ No Supabase connection - using data URL fallback');
                    return null;
                }

                try {
                    // Ensure logos bucket exists
                    await this.ensureLogosStorage();

                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const extension = file.name.split('.').pop() || (file.type.includes('svg') ? 'svg' : 'png');
                    const fileName = `logo-${timestamp}-${randomId}.${extension}`;

                    console.log('üì§ Uploading logo to Supabase Storage...', fileName);

                    // Upload to Supabase Storage with proper headers for SVG
                    const uploadOptions = {
                        cacheControl: '3600',
                        upsert: false
                    };

                    if (file.type.includes('svg')) {
                        uploadOptions.contentType = 'image/svg+xml';
                    }

                    const { data, error } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, file, uploadOptions);

                    if (error) {
                        console.error('‚ùå Storage upload error:', error);
                        throw error;
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('‚úÖ Logo uploaded successfully:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('‚ùå Logo upload failed:', error);
                    return null;
                }
            }

            async uploadSVGCodeToStorage(svgCode) {
                if (!this.supabase || !this.isConnected) {
                    console.log('üìÅ No Supabase connection - using data URL fallback');
                    return null;
                }

                try {
                    // Ensure logos bucket exists
                    await this.ensureLogosStorage();

                    // Generate unique filename
                    const timestamp = Date.now();
                    const randomId = Math.random().toString(36).substring(2, 15);
                    const fileName = `svg-${timestamp}-${randomId}.svg`;

                    console.log('üì§ Uploading SVG code to Supabase Storage...', fileName);

                    // Create blob from SVG code with proper MIME type
                    const blob = new Blob([svgCode], { type: 'image/svg+xml' });

                    // Upload to Supabase Storage
                    const { data, error } = await this.supabase.storage
                        .from('logos')
                        .upload(fileName, blob, {
                            cacheControl: '3600',
                            upsert: false,
                            contentType: 'image/svg+xml'
                        });

                    if (error) {
                        console.error('‚ùå Storage upload error:', error);
                        throw error;
                    }

                    // Get public URL
                    const { data: urlData } = this.supabase.storage
                        .from('logos')
                        .getPublicUrl(fileName);

                    console.log('‚úÖ SVG uploaded successfully:', urlData.publicUrl);
                    return urlData.publicUrl;

                } catch (error) {
                    console.error('‚ùå SVG upload failed:', error);
                    return null;
                }
            }



            exportCanvas() {
                const link = document.createElement('a');
                link.download = 'business-cards.png';
                link.href = this.canvas.toDataURL();
                link.click();
                // No notification needed for export
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.textContent = message;
                document.body.appendChild(notification);

                setTimeout(() => notification.remove(), 3000);
            }
        }

        // Global functions for onclick handlers
        let app;
        let uploadedLogoData = null; // Store uploaded logo data

        function openAddCardModal() {
            document.getElementById('addCardModal').classList.add('show');
            setupFileUpload();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            if (modalId === 'addCardModal') {
                resetFileUpload();
            }
        }

        function setupFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const fileInput = document.getElementById('logoFileInput');
            const uploadContent = uploadArea.querySelector('.upload-content');
            
            // Click to upload
            uploadArea.addEventListener('click', () => {
                if (!uploadArea.querySelector('.logo-preview').style.display || 
                    uploadArea.querySelector('.logo-preview').style.display === 'none') {
                    fileInput.click();
                }
            });
            
            // File input change
            fileInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);
            
            // Paste SVG code
            uploadArea.addEventListener('paste', handlePaste);
            uploadArea.setAttribute('tabindex', '0'); // Make it focusable for paste
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            
            const files = Array.from(e.dataTransfer.files);
            const text = e.dataTransfer.getData('text');
            
            if (files.length > 0) {
                const file = files.find(f => f.type.includes('svg') || f.type.includes('png'));
                if (file) {
                    await processFile(file);
                }
            } else if (text && (text.includes('<svg') || text.startsWith('data:image'))) {
                await processSVGCode(text);
            }
        }

        async function handlePaste(e) {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData('text');
            if (text && text.includes('<svg')) {
                await processSVGCode(text);
            }
        }

        async function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                await processFile(file);
            }
        }

        async function processFile(file) {
            if (!file.type.includes('svg') && !file.type.includes('png')) {
                app.showNotification('Please upload SVG or PNG files only', 'error');
                return;
            }
            
            try {
                // Show loading state
                const uploadArea = document.getElementById('logoUploadArea');
                uploadArea.style.opacity = '0.5';
                uploadArea.style.pointerEvents = 'none';
                
                // Upload to Supabase Storage
                const logoUrl = await app.uploadLogoToStorage(file);
                
                if (logoUrl) {
                    showLogoPreview(logoUrl);
                    uploadedLogoData = logoUrl;
                    console.log('‚úÖ Logo uploaded to Supabase Storage:', logoUrl);
                } else {
                    throw new Error('Upload failed');
                }
            } catch (error) {
                console.error('‚ùå Logo upload failed:', error);
                app.showNotification('Logo upload failed, using local copy', 'error');
                
                // Fallback to data URL
                const reader = new FileReader();
                reader.onload = (e) => {
                    showLogoPreview(e.target.result);
                    uploadedLogoData = e.target.result;
                };
                reader.readAsDataURL(file);
            } finally {
                // Restore upload area
                const uploadArea = document.getElementById('logoUploadArea');
                uploadArea.style.opacity = '1';
                uploadArea.style.pointerEvents = 'auto';
            }
        }

        async function processSVGCode(svgCode) {
            try {
                // Clean and validate SVG
                const cleanSVG = svgCode.trim();
                if (!cleanSVG.includes('<svg')) {
                    throw new Error('Invalid SVG');
                }
                
                try {
                    // Show loading state
                    const uploadArea = document.getElementById('logoUploadArea');
                    uploadArea.style.opacity = '0.5';
                    uploadArea.style.pointerEvents = 'none';
                    
                    // Upload SVG code to Supabase Storage
                    const logoUrl = await app.uploadSVGCodeToStorage(cleanSVG);
                    
                    if (logoUrl) {
                        showLogoPreview(logoUrl);
                        uploadedLogoData = logoUrl;
                        console.log('‚úÖ SVG uploaded to Supabase Storage:', logoUrl);
                    } else {
                        throw new Error('Upload failed');
                    }
                } catch (uploadError) {
                    console.error('‚ùå SVG upload failed:', uploadError);
                    // Fallback to data URL
                    const dataUrl = 'data:image/svg+xml;base64,' + btoa(cleanSVG);
                    showLogoPreview(dataUrl);
                    uploadedLogoData = dataUrl;
                } finally {
                    // Restore upload area
                    const uploadArea = document.getElementById('logoUploadArea');
                    uploadArea.style.opacity = '1';
                    uploadArea.style.pointerEvents = 'auto';
                }
            } catch (error) {
                app.showNotification('Invalid SVG code', 'error');
            }
        }

        function showLogoPreview(dataUrl) {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const previewImg = document.getElementById('logoPreviewImg');
            
            uploadContent.style.display = 'none';
            preview.style.display = 'block';
            previewImg.src = dataUrl;
        }

        function removeLogo() {
            resetFileUpload();
            uploadedLogoData = null;
        }

        function resetFileUpload() {
            const uploadArea = document.getElementById('logoUploadArea');
            const uploadContent = uploadArea.querySelector('.upload-content');
            const preview = document.getElementById('logoPreview');
            const fileInput = document.getElementById('logoFileInput');
            
            uploadContent.style.display = 'block';
            preview.style.display = 'none';
            fileInput.value = '';
            uploadedLogoData = null;
        }

        function addBusinessCard() {
            const companyName = document.getElementById('companyName').value.trim();

            if (!companyName) {
                app.showNotification('Please enter a company name', 'error');
                return;
            }

            if (!app.clickPosition.x && !app.clickPosition.y) {
                app.clickPosition = { x: 400, y: 300 }; // Default position
            }

            app.createCard({
                company: companyName,
                logo: uploadedLogoData, // Use uploaded logo data
                x: app.clickPosition.x,
                y: app.clickPosition.y
            });

            app.render();
            closeModal('addCardModal');
            // No notification needed for adding cards
            
            // Clear form
            document.getElementById('companyName').value = '';
            resetFileUpload();
        }



        function exportCanvas() {
            app.exportCanvas();
        }

        function toggleControlsModal() {
            document.getElementById('controlsModal').classList.add('show');
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            app = new BusinessCardCanvas();
            
            // Style the controls FAB
            const controlsFab = document.getElementById('controlsFab');
            controlsFab.className = 'floating-button controls';
            
            // Setup control sliders and checkbox
            const radiusSlider = document.getElementById('radiusSlider');
            const distanceSlider = document.getElementById('distanceSlider');
            const cardSizeSlider = document.getElementById('cardSizeSlider');
            const radiusValue = document.getElementById('radiusValue');
            const distanceValue = document.getElementById('distanceValue');
            const cardSizeValue = document.getElementById('cardSizeValue');
            const showCirclesCheckbox = document.getElementById('showCirclesCheckbox');
            
            // Update UI with loaded values
            app.updateControlsUI();
            
            radiusSlider.addEventListener('input', (e) => {
                app.circleRadius = parseInt(e.target.value);
                radiusValue.textContent = e.target.value;
                app.render();
                app.saveToSupabase(); // Save setting changes
            });
            
            distanceSlider.addEventListener('input', (e) => {
                app.centerDistance = parseInt(e.target.value);
                distanceValue.textContent = e.target.value;
                app.render();
                app.saveToSupabase(); // Save setting changes
            });
            
            cardSizeSlider.addEventListener('input', (e) => {
                app.cardSize = parseInt(e.target.value);
                cardSizeValue.textContent = e.target.value;
                app.render();
                app.saveToSupabase(); // Save setting changes
            });
            
            showCirclesCheckbox.addEventListener('change', (e) => {
                app.showCircles = e.target.checked;
                app.render();
                app.saveToSupabase(); // Save setting changes
                // No notification needed for simple toggle
            });
            
            console.log('‚úÖ Business Card Canvas ready with real-time collaboration');
            console.log('üåê Multi-device collaboration: Supabase-powered');
            console.log('üíæ Auto-save: Instant across all devices');
            
            // Setup instructions
            if (!app.isConnected) {
                console.log('');
                console.log('üöÄ SETUP SUPABASE FOR REAL COLLABORATION:');
                console.log('1. Go to https://supabase.com and create a project');
                console.log('2. Run this SQL in the SQL Editor:');
                console.log(`
CREATE TABLE canvas_data (
  id text PRIMARY KEY DEFAULT 'shared-canvas',
  cards jsonb DEFAULT '[]'::jsonb,
  settings jsonb DEFAULT '{}'::jsonb,
  updated_at timestamp with time zone DEFAULT now()
);
ALTER PUBLICATION supabase_realtime ADD TABLE canvas_data;
INSERT INTO canvas_data (id) VALUES ('shared-canvas');`);
                console.log('3. Update supabaseConfig with your project URL and anon key');
                console.log('4. Refresh and enjoy real multi-device collaboration! üéâ');
                console.log('');
            }
        });
    </script>
</body>
</html> 